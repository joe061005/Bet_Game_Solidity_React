"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.outputSyncingFormatter = exports.outputPostFormatter = exports.inputPostFormatter = exports.outputBlockFormatter = exports.outputTransactionReceiptFormatter = exports.outputLogFormatter = exports.inputLogFormatter = exports.inputTopicFormatter = exports.outputTransactionFormatter = exports.inputSignFormatter = exports.inputTransactionFormatter = exports.inputCallFormatter = exports.txInputOptionsFormatter = exports.inputAddressFormatter = exports.inputDefaultBlockNumberFormatter = exports.inputBlockNumberFormatter = exports.outputBigIntegerFormatter = exports.outputProofFormatter = exports.inputStorageKeysFormatter = void 0;
const web3_errors_1 = require("web3-errors");
const web3_eth_iban_1 = require("web3-eth-iban");
const web3_types_1 = require("web3-types");
const web3_utils_1 = require("web3-utils");
const web3_validator_1 = require("web3-validator");
const inputStorageKeysFormatter = (keys) => keys.map(web3_utils_1.numberToHex);
exports.inputStorageKeysFormatter = inputStorageKeysFormatter;
const outputProofFormatter = (proof) => ({
    address: (0, web3_utils_1.toChecksumAddress)(proof.address),
    nonce: (0, web3_utils_1.hexToNumberString)(proof.nonce),
    balance: (0, web3_utils_1.hexToNumberString)(proof.balance),
});
exports.outputProofFormatter = outputProofFormatter;
const outputBigIntegerFormatter = (number) => (0, web3_utils_1.toNumber)(number);
exports.outputBigIntegerFormatter = outputBigIntegerFormatter;
const inputBlockNumberFormatter = (blockNumber) => {
    if ((0, web3_validator_1.isNullish)(blockNumber)) {
        return undefined;
    }
    if (typeof blockNumber === 'string' && (0, web3_validator_1.isBlockTag)(blockNumber)) {
        return blockNumber;
    }
    if (blockNumber === 'genesis') {
        return '0x0';
    }
    if (typeof blockNumber === 'string' && (0, web3_utils_1.isHexStrict)(blockNumber)) {
        return blockNumber.toLowerCase();
    }
    return (0, web3_utils_1.numberToHex)(blockNumber);
};
exports.inputBlockNumberFormatter = inputBlockNumberFormatter;
const inputDefaultBlockNumberFormatter = (blockNumber, defaultBlock) => {
    if (!blockNumber) {
        return (0, exports.inputBlockNumberFormatter)(defaultBlock);
    }
    return (0, exports.inputBlockNumberFormatter)(blockNumber);
};
exports.inputDefaultBlockNumberFormatter = inputDefaultBlockNumberFormatter;
const inputAddressFormatter = (address) => {
    if (web3_eth_iban_1.Iban.isValid(address) && web3_eth_iban_1.Iban.isDirect(address)) {
        const iban = new web3_eth_iban_1.Iban(address);
        return iban.toAddress().toLowerCase();
    }
    if ((0, web3_utils_1.isAddress)(address)) {
        return `0x${address.toLowerCase().replace('0x', '')}`;
    }
    throw new web3_errors_1.FormatterError(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);
};
exports.inputAddressFormatter = inputAddressFormatter;
const txInputOptionsFormatter = (options) => {
    var _a;
    const modifiedOptions = Object.assign({}, options);
    if (options.to) {
        modifiedOptions.to = (0, exports.inputAddressFormatter)(options.to);
    }
    if (options.data && options.input) {
        throw new web3_errors_1.FormatterError('You can\'t have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.');
    }
    if (!options.data && options.input) {
        modifiedOptions.data = options.input;
        delete modifiedOptions.input;
    }
    if (options.data && !options.data.startsWith('0x')) {
        modifiedOptions.data = `0x${options.data}`;
    }
    if (modifiedOptions.data && !(0, web3_utils_1.isHexStrict)(modifiedOptions.data)) {
        throw new web3_errors_1.FormatterError('The data field must be HEX encoded data.');
    }
    if (options.gas || options.gasLimit) {
        modifiedOptions.gas = (0, web3_utils_1.toNumber)((_a = options.gas) !== null && _a !== void 0 ? _a : options.gasLimit);
    }
    if (options.maxPriorityFeePerGas || options.maxFeePerGas) {
        delete modifiedOptions.gasPrice;
    }
    ['gasPrice', 'gas', 'value', 'maxPriorityFeePerGas', 'maxFeePerGas', 'nonce', 'chainId']
        .filter(key => !(0, web3_validator_1.isNullish)(modifiedOptions[key]))
        .forEach(key => {
        modifiedOptions[key] = (0, web3_utils_1.numberToHex)(modifiedOptions[key]);
    });
    return modifiedOptions;
};
exports.txInputOptionsFormatter = txInputOptionsFormatter;
const inputCallFormatter = (options, defaultAccount) => {
    var _a;
    const opts = (0, exports.txInputOptionsFormatter)(options);
    const from = (_a = opts.from) !== null && _a !== void 0 ? _a : defaultAccount;
    if (from) {
        opts.from = (0, exports.inputAddressFormatter)(from);
    }
    return opts;
};
exports.inputCallFormatter = inputCallFormatter;
const inputTransactionFormatter = (options, defaultAccount) => {
    var _a;
    const opts = (0, exports.txInputOptionsFormatter)(options);
    if (!(typeof opts.from === 'number') && !(!!opts.from && typeof opts.from === 'object')) {
        opts.from = (_a = opts.from) !== null && _a !== void 0 ? _a : defaultAccount;
        if (!options.from && !(typeof options.from === 'number')) {
            throw new web3_errors_1.FormatterError('The send transactions "from" field must be defined!');
        }
        opts.from = (0, exports.inputAddressFormatter)(options.from);
    }
    return opts;
};
exports.inputTransactionFormatter = inputTransactionFormatter;
const inputSignFormatter = (data) => ((0, web3_utils_1.isHexStrict)(data) ? data : (0, web3_utils_1.utf8ToHex)(data));
exports.inputSignFormatter = inputSignFormatter;
const outputTransactionFormatter = (tx) => {
    const modifiedTx = Object.assign({}, tx);
    if (tx.blockNumber) {
        modifiedTx.blockNumber = (0, web3_utils_1.hexToNumber)(tx.blockNumber);
    }
    if (tx.transactionIndex) {
        modifiedTx.transactionIndex = (0, web3_utils_1.hexToNumber)(tx.transactionIndex);
    }
    modifiedTx.nonce = (0, web3_utils_1.hexToNumber)(tx.nonce);
    modifiedTx.gas = (0, web3_utils_1.hexToNumber)(tx.gas);
    if (tx.gasPrice) {
        modifiedTx.gasPrice = (0, exports.outputBigIntegerFormatter)(tx.gasPrice);
    }
    if (tx.maxFeePerGas) {
        modifiedTx.maxFeePerGas = (0, exports.outputBigIntegerFormatter)(tx.maxFeePerGas);
    }
    if (tx.maxPriorityFeePerGas) {
        modifiedTx.maxPriorityFeePerGas = (0, exports.outputBigIntegerFormatter)(tx.maxPriorityFeePerGas);
    }
    if (tx.type) {
        modifiedTx.type = (0, web3_utils_1.hexToNumber)(tx.type);
    }
    modifiedTx.value = (0, exports.outputBigIntegerFormatter)(tx.value);
    if (tx.to && (0, web3_utils_1.isAddress)(tx.to)) {
        modifiedTx.to = (0, web3_utils_1.toChecksumAddress)(tx.to);
    }
    else {
        modifiedTx.to = undefined;
    }
    if (tx.from) {
        modifiedTx.from = (0, web3_utils_1.toChecksumAddress)(tx.from);
    }
    return modifiedTx;
};
exports.outputTransactionFormatter = outputTransactionFormatter;
const inputTopicFormatter = (topic) => {
    if ((0, web3_validator_1.isNullish)(topic))
        return null;
    const value = String(topic);
    return (0, web3_validator_1.isHex)(value) ? value : (0, web3_utils_1.fromUtf8)(value);
};
exports.inputTopicFormatter = inputTopicFormatter;
const inputLogFormatter = (filter) => {
    var _a;
    const val = (0, web3_validator_1.isNullish)(filter)
        ? {}
        : (0, web3_utils_1.mergeDeep)({}, filter);
    if ((0, web3_validator_1.isNullish)(val.fromBlock)) {
        val.fromBlock = web3_types_1.BlockTags.LATEST;
    }
    val.fromBlock = (0, exports.inputBlockNumberFormatter)(val.fromBlock);
    if (!(0, web3_validator_1.isNullish)(val.toBlock)) {
        val.toBlock = (0, exports.inputBlockNumberFormatter)(val.toBlock);
    }
    val.topics = (_a = val.topics) !== null && _a !== void 0 ? _a : [];
    val.topics = val.topics.map(topic => Array.isArray(topic)
        ? topic.map(exports.inputTopicFormatter)
        : (0, exports.inputTopicFormatter)(topic));
    if (val.address) {
        val.address = Array.isArray(val.address)
            ? val.address.map(addr => (0, exports.inputAddressFormatter)(addr))
            : (0, exports.inputAddressFormatter)(val.address);
    }
    return val;
};
exports.inputLogFormatter = inputLogFormatter;
const outputLogFormatter = (log) => {
    const modifiedLog = Object.assign({}, log);
    const logIndex = typeof log.logIndex === 'string'
        ? log.logIndex
        : (0, web3_utils_1.numberToHex)(log.logIndex);
    if (typeof log.blockHash === 'string' && typeof log.transactionHash === 'string') {
        const shaId = (0, web3_utils_1.sha3Raw)(`${log.blockHash.replace('0x', '')}${log.transactionHash.replace('0x', '')}${logIndex.replace('0x', '')}`);
        modifiedLog.id = `log_${shaId.replace('0x', '').slice(0, 8)}`;
    }
    else if (!log.id) {
        modifiedLog.id = undefined;
    }
    if (log.blockNumber && (0, web3_utils_1.isHexStrict)(log.blockNumber)) {
        modifiedLog.blockNumber = (0, web3_utils_1.hexToNumber)(log.blockNumber);
    }
    if (log.transactionIndex && (0, web3_utils_1.isHexStrict)(log.transactionIndex)) {
        modifiedLog.transactionIndex = (0, web3_utils_1.hexToNumber)(log.transactionIndex);
    }
    if (log.logIndex && (0, web3_utils_1.isHexStrict)(log.logIndex)) {
        modifiedLog.logIndex = (0, web3_utils_1.hexToNumber)(log.logIndex);
    }
    if (log.address) {
        modifiedLog.address = (0, web3_utils_1.toChecksumAddress)(log.address);
    }
    return modifiedLog;
};
exports.outputLogFormatter = outputLogFormatter;
const outputTransactionReceiptFormatter = (receipt) => {
    if (typeof receipt !== 'object') {
        throw new web3_errors_1.FormatterError(`Received receipt is invalid: ${String(receipt)}`);
    }
    const modifiedReceipt = Object.assign({}, receipt);
    if (receipt.blockNumber) {
        modifiedReceipt.blockNumber = (0, web3_utils_1.hexToNumber)(receipt.blockNumber);
    }
    if (receipt.transactionIndex) {
        modifiedReceipt.transactionIndex = (0, web3_utils_1.hexToNumber)(receipt.transactionIndex);
    }
    modifiedReceipt.cumulativeGasUsed = (0, web3_utils_1.hexToNumber)(receipt.cumulativeGasUsed);
    modifiedReceipt.gasUsed = (0, web3_utils_1.hexToNumber)(receipt.gasUsed);
    if (receipt.logs && Array.isArray(receipt.logs)) {
        modifiedReceipt.logs = receipt.logs.map(exports.outputLogFormatter);
    }
    if (receipt.effectiveGasPrice) {
        modifiedReceipt.effectiveGasPrice = (0, web3_utils_1.hexToNumber)(receipt.effectiveGasPrice);
    }
    if (receipt.contractAddress) {
        modifiedReceipt.contractAddress = (0, web3_utils_1.toChecksumAddress)(receipt.contractAddress);
    }
    if (receipt.status) {
        modifiedReceipt.status = Boolean(parseInt(receipt.status, 10));
    }
    return modifiedReceipt;
};
exports.outputTransactionReceiptFormatter = outputTransactionReceiptFormatter;
const outputBlockFormatter = (block) => {
    const modifiedBlock = Object.assign({}, block);
    modifiedBlock.gasLimit = (0, web3_utils_1.hexToNumber)(block.gasLimit);
    modifiedBlock.gasUsed = (0, web3_utils_1.hexToNumber)(block.gasUsed);
    modifiedBlock.size = (0, web3_utils_1.hexToNumber)(block.size);
    modifiedBlock.timestamp = (0, web3_utils_1.hexToNumber)(block.timestamp);
    if (block.number) {
        modifiedBlock.number = (0, web3_utils_1.hexToNumber)(block.number);
    }
    if (block.difficulty) {
        modifiedBlock.difficulty = (0, exports.outputBigIntegerFormatter)(block.difficulty);
    }
    if (block.totalDifficulty) {
        modifiedBlock.totalDifficulty = (0, exports.outputBigIntegerFormatter)(block.totalDifficulty);
    }
    if (block.transactions && Array.isArray(block.transactions)) {
        modifiedBlock.transactions = block.transactions.map(exports.outputTransactionFormatter);
    }
    if (block.miner) {
        modifiedBlock.miner = (0, web3_utils_1.toChecksumAddress)(block.miner);
    }
    if (block.baseFeePerGas) {
        modifiedBlock.baseFeePerGas = (0, web3_utils_1.hexToNumber)(block.baseFeePerGas);
    }
    return modifiedBlock;
};
exports.outputBlockFormatter = outputBlockFormatter;
const inputPostFormatter = (post) => {
    var _a;
    const modifiedPost = Object.assign({}, post);
    if (post.ttl) {
        modifiedPost.ttl = (0, web3_utils_1.numberToHex)(post.ttl);
    }
    if (post.workToProve) {
        modifiedPost.workToProve = (0, web3_utils_1.numberToHex)(post.workToProve);
    }
    if (post.priority) {
        modifiedPost.priority = (0, web3_utils_1.numberToHex)(post.priority);
    }
    if (post.topics && !Array.isArray(post.topics)) {
        modifiedPost.topics = post.topics ? [post.topics] : [];
    }
    modifiedPost.topics = (_a = modifiedPost.topics) === null || _a === void 0 ? void 0 : _a.map(topic => topic.startsWith('0x') ? topic : (0, web3_utils_1.fromUtf8)(topic));
    return modifiedPost;
};
exports.inputPostFormatter = inputPostFormatter;
const outputPostFormatter = (post) => {
    var _a;
    const modifiedPost = Object.assign({}, post);
    if (post.expiry) {
        modifiedPost.expiry = (0, web3_utils_1.hexToNumber)(post.expiry);
    }
    if (post.sent) {
        modifiedPost.sent = (0, web3_utils_1.hexToNumber)(post.sent);
    }
    if (post.ttl) {
        modifiedPost.ttl = (0, web3_utils_1.hexToNumber)(post.ttl);
    }
    if (post.workProved) {
        modifiedPost.workProved = (0, web3_utils_1.hexToNumber)(post.workProved);
    }
    if (!post.topics) {
        modifiedPost.topics = [];
    }
    modifiedPost.topics = (_a = modifiedPost.topics) === null || _a === void 0 ? void 0 : _a.map(web3_utils_1.toUtf8);
    return modifiedPost;
};
exports.outputPostFormatter = outputPostFormatter;
const outputSyncingFormatter = (result) => {
    const modifiedResult = Object.assign({}, result);
    modifiedResult.startingBlock = (0, web3_utils_1.hexToNumber)(result.startingBlock);
    modifiedResult.currentBlock = (0, web3_utils_1.hexToNumber)(result.currentBlock);
    modifiedResult.highestBlock = (0, web3_utils_1.hexToNumber)(result.highestBlock);
    if (result.knownStates) {
        modifiedResult.knownStates = (0, web3_utils_1.hexToNumber)(result.knownStates);
    }
    if (result.pulledStates) {
        modifiedResult.pulledStates = (0, web3_utils_1.hexToNumber)(result.pulledStates);
    }
    return modifiedResult;
};
exports.outputSyncingFormatter = outputSyncingFormatter;
//# sourceMappingURL=formatters.js.map