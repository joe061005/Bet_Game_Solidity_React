"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3RequestManager = exports.Web3RequestManagerEvent = void 0;
const web3_errors_1 = require("web3-errors");
const web3_providers_http_1 = __importDefault(require("web3-providers-http"));
const web3_providers_ipc_1 = __importDefault(require("web3-providers-ipc"));
const web3_providers_ws_1 = __importDefault(require("web3-providers-ws"));
const web3_utils_1 = require("web3-utils");
const utils_1 = require("./utils");
const web3_event_emitter_1 = require("./web3_event_emitter");
var Web3RequestManagerEvent;
(function (Web3RequestManagerEvent) {
    Web3RequestManagerEvent["PROVIDER_CHANGED"] = "PROVIDER_CHANGED";
    Web3RequestManagerEvent["BEFORE_PROVIDER_CHANGE"] = "BEFORE_PROVIDER_CHANGE";
})(Web3RequestManagerEvent = exports.Web3RequestManagerEvent || (exports.Web3RequestManagerEvent = {}));
const availableProviders = {
    HttpProvider: web3_providers_http_1.default,
    WebsocketProvider: web3_providers_ws_1.default,
    IpcProvider: web3_providers_ipc_1.default,
};
class Web3RequestManager extends web3_event_emitter_1.Web3EventEmitter {
    constructor(provider, net, useRpcCallSpecification) {
        super();
        if (!(0, web3_utils_1.isNullish)(provider)) {
            this.setProvider(provider, net);
        }
        this.useRpcCallSpecification = useRpcCallSpecification;
    }
    static get providers() {
        return availableProviders;
    }
    get provider() {
        return this._provider;
    }
    get providers() {
        return availableProviders;
    }
    setProvider(provider, net) {
        let newProvider;
        if (provider && typeof provider === 'string' && this.providers) {
            if (/^http(s)?:\/\//i.test(provider)) {
                newProvider = new this.providers.HttpProvider(provider);
            }
            else if (/^ws(s)?:\/\//i.test(provider)) {
                newProvider = new this.providers.WebsocketProvider(provider);
            }
            else if (typeof net === 'object' && typeof net.connect === 'function') {
                newProvider = new this.providers.IpcProvider(provider, net);
            }
            else if (provider.toLowerCase().endsWith('.ipc')) {
                newProvider = new this.providers.IpcProvider(provider);
            }
            else {
                throw new web3_errors_1.ProviderError(`Can't autodetect provider for "${provider}"`);
            }
        }
        else if ((0, web3_utils_1.isNullish)(provider)) {
            newProvider = undefined;
        }
        else {
            newProvider = provider;
        }
        this.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);
        this._provider = newProvider;
        this.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);
        return true;
    }
    send(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._sendRequest(request);
            if (web3_utils_1.jsonRpc.isResponseWithResult(response)) {
                return response.result;
            }
            throw new web3_errors_1.ResponseError(response);
        });
    }
    sendBatch(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._sendRequest(request);
            return response;
        });
    }
    _sendRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider } = this;
            if ((0, web3_utils_1.isNullish)(provider)) {
                throw new web3_errors_1.ProviderError('Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.');
            }
            const payload = web3_utils_1.jsonRpc.isBatchRequest(request)
                ? web3_utils_1.jsonRpc.toBatchPayload(request)
                : web3_utils_1.jsonRpc.toPayload(request);
            if ((0, utils_1.isWeb3Provider)(provider)) {
                let response;
                try {
                    response = yield provider.request(payload);
                }
                catch (error) {
                    response = error;
                }
                return this._processJsonRpcResponse(payload, response, { legacy: false, error: false });
            }
            if ((0, utils_1.isEIP1193Provider)(provider)) {
                return provider
                    .request(payload)
                    .then(res => this._processJsonRpcResponse(payload, res, {
                    legacy: true,
                    error: false,
                }))
                    .catch(error => this._processJsonRpcResponse(payload, error, { legacy: true, error: true }));
            }
            if ((0, utils_1.isLegacyRequestProvider)(provider)) {
                return new Promise((resolve, reject) => {
                    const rejectWithError = (err) => reject(this._processJsonRpcResponse(payload, err, {
                        legacy: true,
                        error: true,
                    }));
                    const resolveWithResponse = (response) => resolve(this._processJsonRpcResponse(payload, response, {
                        legacy: true,
                        error: false,
                    }));
                    const result = provider.request(payload, (err, response) => {
                        if (err) {
                            return rejectWithError(err);
                        }
                        return resolveWithResponse(response);
                    });
                    if ((0, web3_utils_1.isPromise)(result)) {
                        const responsePromise = result;
                        responsePromise.then(resolveWithResponse).catch(rejectWithError);
                    }
                });
            }
            if ((0, utils_1.isLegacySendProvider)(provider)) {
                return new Promise((resolve, reject) => {
                    provider.send(payload, (err, response) => {
                        if (err) {
                            return reject(this._processJsonRpcResponse(payload, err, {
                                legacy: true,
                                error: true,
                            }));
                        }
                        if ((0, web3_utils_1.isNullish)(response)) {
                            throw new web3_errors_1.ResponseError('', 'Got a "nullish" response from provider.');
                        }
                        return resolve(this._processJsonRpcResponse(payload, response, {
                            legacy: true,
                            error: false,
                        }));
                    });
                });
            }
            if ((0, utils_1.isLegacySendAsyncProvider)(provider)) {
                return provider
                    .sendAsync(payload)
                    .then(response => this._processJsonRpcResponse(payload, response, { legacy: true, error: false }))
                    .catch(error => this._processJsonRpcResponse(payload, error, {
                    legacy: true,
                    error: true,
                }));
            }
            throw new web3_errors_1.ProviderError('Provider does not have a request or send method to use.');
        });
    }
    _processJsonRpcResponse(payload, response, { legacy, error }) {
        if ((0, web3_utils_1.isNullish)(response)) {
            return this._buildResponse(payload, null, error);
        }
        if (web3_utils_1.jsonRpc.isResponseWithError(response)) {
            if (this.useRpcCallSpecification &&
                (0, web3_utils_1.isResponseRpcError)(response)) {
                const rpcErrorResponse = response;
                if (web3_errors_1.rpcErrorsMap.get(rpcErrorResponse.error.code)) {
                    const Err = web3_errors_1.rpcErrorsMap.get(rpcErrorResponse.error.code).error;
                    throw new Err(rpcErrorResponse);
                }
                else {
                    throw new web3_errors_1.RpcError(rpcErrorResponse);
                }
            }
            else if (!Web3RequestManager._isReverted(response)) {
                throw new web3_errors_1.InvalidResponseError(response, payload);
            }
        }
        if (web3_utils_1.jsonRpc.isResponseWithResult(response)) {
            return response;
        }
        if (response instanceof Error) {
            Web3RequestManager._isReverted(response);
            throw response;
        }
        if (!legacy && web3_utils_1.jsonRpc.isBatchRequest(payload) && web3_utils_1.jsonRpc.isBatchResponse(response)) {
            return response;
        }
        if (legacy && !error && web3_utils_1.jsonRpc.isBatchRequest(payload)) {
            return response;
        }
        if (legacy && error && web3_utils_1.jsonRpc.isBatchRequest(payload)) {
            throw response;
        }
        if (legacy &&
            !web3_utils_1.jsonRpc.isResponseWithError(response) &&
            !web3_utils_1.jsonRpc.isResponseWithResult(response)) {
            return this._buildResponse(payload, response, error);
        }
        if (web3_utils_1.jsonRpc.isBatchRequest(payload) && !Array.isArray(response)) {
            throw new web3_errors_1.ResponseError(response, 'Got normal response for a batch request.');
        }
        if (!web3_utils_1.jsonRpc.isBatchRequest(payload) && Array.isArray(response)) {
            throw new web3_errors_1.ResponseError(response, 'Got batch response for a normal request.');
        }
        if ((web3_utils_1.jsonRpc.isResponseWithError(response) || web3_utils_1.jsonRpc.isResponseWithResult(response)) &&
            !web3_utils_1.jsonRpc.isBatchRequest(payload)) {
            if (response.id && payload.id !== response.id) {
                throw new web3_errors_1.InvalidResponseError(response);
            }
        }
        throw new web3_errors_1.ResponseError(response, 'Invalid response');
    }
    static _isReverted(response) {
        let error;
        if (web3_utils_1.jsonRpc.isResponseWithError(response)) {
            error = response.error;
        }
        else if (response instanceof Error) {
            error = response;
        }
        if (error === null || error === void 0 ? void 0 : error.message.includes('revert'))
            throw new web3_errors_1.ContractExecutionError(error);
        return false;
    }
    _buildResponse(payload, response, error) {
        const res = {
            jsonrpc: '2.0',
            id: web3_utils_1.jsonRpc.isBatchRequest(payload)
                ? payload[0].id
                : 'id' in payload
                    ? payload.id
                    :
                        null,
        };
        if (error) {
            return Object.assign(Object.assign({}, res), { error: response });
        }
        return Object.assign(Object.assign({}, res), { result: response });
    }
}
exports.Web3RequestManager = Web3RequestManager;
//# sourceMappingURL=web3_request_manager.js.map