"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Contract = void 0;
const web3_core_1 = require("web3-core");
const web3_errors_1 = require("web3-errors");
const web3_eth_1 = require("web3-eth");
const web3_eth_abi_1 = require("web3-eth-abi");
const web3_types_1 = require("web3-types");
const web3_utils_1 = require("web3-utils");
const web3_validator_1 = require("web3-validator");
const constants_1 = require("./constants");
const encoding_1 = require("./encoding");
const log_subscription_1 = require("./log_subscription");
const utils_1 = require("./utils");
const contractSubscriptions = {
    logs: log_subscription_1.LogsSubscription,
    newHeads: web3_eth_1.NewHeadsSubscription,
    newBlockHeaders: web3_eth_1.NewHeadsSubscription,
};
class Contract extends web3_core_1.Web3Context {
    constructor(jsonInterface, addressOrOptionsOrContext, optionsOrContextOrReturnFormat, contextOrReturnFormat, returnFormat) {
        var _a, _b;
        let contractContext;
        if ((0, utils_1.isWeb3ContractContext)(addressOrOptionsOrContext)) {
            contractContext = addressOrOptionsOrContext;
        }
        else if ((0, utils_1.isWeb3ContractContext)(optionsOrContextOrReturnFormat)) {
            contractContext = optionsOrContextOrReturnFormat;
        }
        else {
            contractContext = contextOrReturnFormat;
        }
        let provider;
        if (typeof addressOrOptionsOrContext === 'object' &&
            'provider' in addressOrOptionsOrContext) {
            provider = addressOrOptionsOrContext.provider;
        }
        else if (typeof optionsOrContextOrReturnFormat === 'object' &&
            'provider' in optionsOrContextOrReturnFormat) {
            provider = optionsOrContextOrReturnFormat.provider;
        }
        else if (typeof contextOrReturnFormat === 'object' &&
            'provider' in contextOrReturnFormat) {
            provider = contextOrReturnFormat.provider;
        }
        else {
            provider = Contract.givenProvider;
        }
        super(Object.assign(Object.assign({}, contractContext), { provider, registeredSubscriptions: contractSubscriptions }));
        this.syncWithContext = false;
        this._functions = {};
        this._overloadedMethodAbis = new Map();
        const returnDataFormat = (0, web3_utils_1.isDataFormat)(contextOrReturnFormat)
            ? contextOrReturnFormat
            : (0, web3_utils_1.isDataFormat)(optionsOrContextOrReturnFormat)
                ? optionsOrContextOrReturnFormat
                : returnFormat !== null && returnFormat !== void 0 ? returnFormat : web3_utils_1.DEFAULT_RETURN_FORMAT;
        const address = typeof addressOrOptionsOrContext === 'string' ? addressOrOptionsOrContext : undefined;
        const options = (0, utils_1.isContractInitOptions)(addressOrOptionsOrContext)
            ? addressOrOptionsOrContext
            : (0, utils_1.isContractInitOptions)(optionsOrContextOrReturnFormat)
                ? optionsOrContextOrReturnFormat
                : undefined;
        this._parseAndSetJsonInterface(jsonInterface, returnDataFormat);
        if (!(0, web3_validator_1.isNullish)(address)) {
            this._parseAndSetAddress(address, returnDataFormat);
        }
        this.options = {
            address,
            jsonInterface: this._jsonInterface,
            gas: (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.gasLimit,
            gasPrice: options === null || options === void 0 ? void 0 : options.gasPrice,
            gasLimit: options === null || options === void 0 ? void 0 : options.gasLimit,
            from: options === null || options === void 0 ? void 0 : options.from,
            data: options === null || options === void 0 ? void 0 : options.data,
        };
        this.syncWithContext = (_b = options === null || options === void 0 ? void 0 : options.syncWithContext) !== null && _b !== void 0 ? _b : false;
        if (contractContext instanceof web3_core_1.Web3Context) {
            this.subscribeToContextEvents(contractContext);
        }
        Object.defineProperty(this.options, 'address', {
            set: (value) => this._parseAndSetAddress(value, returnDataFormat),
            get: () => this._address,
        });
        Object.defineProperty(this.options, 'jsonInterface', {
            set: (value) => this._parseAndSetJsonInterface(value, returnDataFormat),
            get: () => this._jsonInterface,
        });
    }
    get events() {
        return this._events;
    }
    get methods() {
        return this._methods;
    }
    clone() {
        let newContract;
        if (this.options.address) {
            newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], this.options.address, {
                gas: this.options.gas,
                gasPrice: this.options.gasPrice,
                gasLimit: this.options.gasLimit,
                from: this.options.from,
                data: this.options.data,
                provider: this.currentProvider,
                syncWithContext: this.syncWithContext,
            }, this.getContextObject());
        }
        else {
            newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], {
                gas: this.options.gas,
                gasPrice: this.options.gasPrice,
                gasLimit: this.options.gasLimit,
                from: this.options.from,
                data: this.options.data,
                provider: this.currentProvider,
                syncWithContext: this.syncWithContext,
            }, this.getContextObject());
        }
        if (this.context)
            newContract.subscribeToContextEvents(this.context);
        return newContract;
    }
    deploy(deployOptions) {
        var _a, _b;
        let abi = this._jsonInterface.find(j => j.type === 'constructor');
        if (!abi) {
            abi = {
                type: 'constructor',
                inputs: [],
                stateMutability: '',
            };
        }
        const data = (0, web3_utils_1.format)({ eth: 'bytes' }, (_a = deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.data) !== null && _a !== void 0 ? _a : this.options.data, web3_utils_1.DEFAULT_RETURN_FORMAT);
        if (!data || data.trim() === '0x') {
            throw new web3_errors_1.Web3ContractError('contract creation without any data provided.');
        }
        const args = (_b = deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.arguments) !== null && _b !== void 0 ? _b : [];
        const contractOptions = Object.assign(Object.assign({}, this.options), { data });
        return {
            arguments: args,
            send: (options) => {
                const modifiedOptions = Object.assign({}, options);
                delete modifiedOptions.to;
                return this._contractMethodDeploySend(abi, args, modifiedOptions, contractOptions);
            },
            estimateGas: (options, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) => __awaiter(this, void 0, void 0, function* () {
                const modifiedOptions = Object.assign({}, options);
                delete modifiedOptions.to;
                return this._contractMethodEstimateGas({
                    abi: abi,
                    params: args,
                    returnFormat,
                    options: modifiedOptions,
                    contractOptions,
                });
            }),
            encodeABI: () => (0, encoding_1.encodeMethodABI)(abi, args, (0, web3_utils_1.format)({ eth: 'bytes' }, data, web3_utils_1.DEFAULT_RETURN_FORMAT)),
        };
    }
    getPastEvents(param1, param2, param3) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventName = typeof param1 === 'string' ? param1 : 'allEvents';
            const filter = typeof param1 !== 'string' && !(0, web3_utils_1.isDataFormat)(param1)
                ? param1
                : !(0, web3_utils_1.isDataFormat)(param2)
                    ? param2
                    : {};
            const returnFormat = (0, web3_utils_1.isDataFormat)(param1)
                ? param1
                : (0, web3_utils_1.isDataFormat)(param2)
                    ? param2
                    : param3 !== null && param3 !== void 0 ? param3 : web3_utils_1.DEFAULT_RETURN_FORMAT;
            const abi = eventName === 'allEvents'
                ? constants_1.ALL_EVENTS_ABI
                : this._jsonInterface.find(j => 'name' in j && j.name === eventName);
            if (!abi) {
                throw new web3_errors_1.Web3ContractError(`Event ${eventName} not found.`);
            }
            const { fromBlock, toBlock, topics, address } = (0, encoding_1.encodeEventABI)(this.options, abi, filter !== null && filter !== void 0 ? filter : {});
            const logs = yield (0, web3_eth_1.getLogs)(this, { fromBlock, toBlock, topics, address }, returnFormat);
            return logs.map(log => typeof log === 'string'
                ? log
                : (0, encoding_1.decodeEventABI)(abi, log, this._jsonInterface, returnFormat));
        });
    }
    _parseAndSetAddress(value, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) {
        this._address = value
            ? (0, web3_utils_1.toChecksumAddress)((0, web3_utils_1.format)({ eth: 'address' }, value, returnFormat))
            : value;
    }
    _parseAndSetJsonInterface(abis, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) {
        var _a, _b, _c, _d, _e;
        this._functions = {};
        this._methods = {};
        this._events = {};
        let result = [];
        const functionsAbi = abis.filter(abi => abi.type !== 'error');
        const errorsAbi = abis.filter(abi => (0, web3_eth_abi_1.isAbiErrorFragment)(abi));
        for (const a of functionsAbi) {
            const abi = Object.assign(Object.assign({}, a), { signature: '' });
            if ((0, web3_eth_abi_1.isAbiFunctionFragment)(abi)) {
                const methodName = (0, web3_eth_abi_1.jsonInterfaceMethodToString)(abi);
                const methodSignature = (0, web3_eth_abi_1.encodeFunctionSignature)(methodName);
                abi.signature = methodSignature;
                abi.constant =
                    (_b = (_a = abi.stateMutability === 'view') !== null && _a !== void 0 ? _a : abi.stateMutability === 'pure') !== null && _b !== void 0 ? _b : abi.constant;
                abi.payable = (_c = abi.stateMutability === 'payable') !== null && _c !== void 0 ? _c : abi.payable;
                this._overloadedMethodAbis.set(abi.name, [
                    ...((_d = this._overloadedMethodAbis.get(abi.name)) !== null && _d !== void 0 ? _d : []),
                    abi,
                ]);
                const contractMethod = this._createContractMethod((_e = this._overloadedMethodAbis.get(abi.name)) !== null && _e !== void 0 ? _e : [], errorsAbi);
                this._functions[methodName] = {
                    signature: methodSignature,
                    method: contractMethod,
                };
                this._methods[abi.name] = this._functions[methodName].method;
                this._methods[methodName] = this._functions[methodName].method;
                this._methods[methodSignature] = this
                    ._functions[methodName].method;
            }
            else if ((0, web3_eth_abi_1.isAbiEventFragment)(abi)) {
                const eventName = (0, web3_eth_abi_1.jsonInterfaceMethodToString)(abi);
                const eventSignature = (0, web3_eth_abi_1.encodeEventSignature)(eventName);
                const event = this._createContractEvent(abi, returnFormat);
                abi.signature = eventSignature;
                if (!(eventName in this._events) || abi.name === 'bound') {
                    this._events[eventName] = event;
                }
                this._events[abi.name] = event;
                this._events[eventSignature] = event;
            }
            this._events.allEvents = this._createContractEvent(constants_1.ALL_EVENTS_ABI, returnFormat);
            result = [...result, abi];
        }
        this._jsonInterface = [...result];
        this._errorsInterface = errorsAbi;
    }
    _getAbiParams(abi, params) {
        var _a;
        try {
            return web3_validator_1.utils.transformJsonDataToAbiFormat((_a = abi.inputs) !== null && _a !== void 0 ? _a : [], params);
        }
        catch (error) {
            throw new web3_errors_1.Web3ContractError(`Invalid parameters for method ${abi.name}: ${error.message}`);
        }
    }
    _createContractMethod(abiArr, errorsAbis) {
        const abi = abiArr[abiArr.length - 1];
        return (...params) => {
            var _a, _b;
            let abiParams;
            const abis = (_a = this._overloadedMethodAbis.get(abi.name)) !== null && _a !== void 0 ? _a : [];
            let methodAbi = abis[0];
            const internalErrorsAbis = errorsAbis;
            const arrayOfAbis = abis.filter(_abi => { var _a; return ((_a = _abi.inputs) !== null && _a !== void 0 ? _a : []).length === params.length; });
            if (abis.length === 1 || arrayOfAbis.length === 0) {
                abiParams = this._getAbiParams(methodAbi, params);
                web3_validator_1.validator.validate((_b = abi.inputs) !== null && _b !== void 0 ? _b : [], abiParams);
            }
            else {
                const errors = [];
                for (const _abi of arrayOfAbis) {
                    try {
                        abiParams = this._getAbiParams(_abi, params);
                        web3_validator_1.validator.validate(_abi.inputs, abiParams);
                        methodAbi = _abi;
                        break;
                    }
                    catch (e) {
                        errors.push(e);
                    }
                }
                if (errors.length === arrayOfAbis.length) {
                    throw new web3_validator_1.Web3ValidatorError(errors);
                }
            }
            if (methodAbi.stateMutability === 'payable') {
                return {
                    arguments: abiParams,
                    call: (options, block) => __awaiter(this, void 0, void 0, function* () {
                        return this._contractMethodCall(methodAbi, abiParams, internalErrorsAbis, options, block);
                    }),
                    send: (options) => this._contractMethodSend(methodAbi, abiParams, internalErrorsAbis, options),
                    estimateGas: (options, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) => __awaiter(this, void 0, void 0, function* () {
                        return this._contractMethodEstimateGas({
                            abi: methodAbi,
                            params: abiParams,
                            returnFormat,
                            options,
                        });
                    }),
                    encodeABI: () => (0, encoding_1.encodeMethodABI)(methodAbi, abiParams),
                    createAccessList: (options, block) => __awaiter(this, void 0, void 0, function* () {
                        return this._contractMethodCreateAccessList(methodAbi, abiParams, internalErrorsAbis, options, block);
                    }),
                };
            }
            return {
                arguments: abiParams,
                call: (options, block) => __awaiter(this, void 0, void 0, function* () {
                    return this._contractMethodCall(methodAbi, abiParams, internalErrorsAbis, options, block);
                }),
                send: (options) => this._contractMethodSend(methodAbi, abiParams, internalErrorsAbis, options),
                estimateGas: (options, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) => __awaiter(this, void 0, void 0, function* () {
                    return this._contractMethodEstimateGas({
                        abi: methodAbi,
                        params: abiParams,
                        returnFormat,
                        options,
                    });
                }),
                encodeABI: () => (0, encoding_1.encodeMethodABI)(methodAbi, abiParams),
                createAccessList: (options, block) => __awaiter(this, void 0, void 0, function* () {
                    return this._contractMethodCreateAccessList(methodAbi, abiParams, internalErrorsAbis, options, block);
                }),
            };
        };
    }
    _contractMethodCall(abi, params, errorsAbi, options, block) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const tx = (0, utils_1.getEthTxCallParams)({
                abi,
                params,
                options,
                contractOptions: Object.assign(Object.assign({}, this.options), { from: (_a = this.options.from) !== null && _a !== void 0 ? _a : this.getConfig().defaultAccount }),
            });
            try {
                const result = yield (0, web3_eth_1.call)(this, tx, block, web3_utils_1.DEFAULT_RETURN_FORMAT);
                return (0, encoding_1.decodeMethodReturn)(abi, result);
            }
            catch (error) {
                if (error instanceof web3_errors_1.ContractExecutionError) {
                    (0, web3_eth_abi_1.decodeContractErrorData)(errorsAbi, error.innerError);
                }
                throw error;
            }
        });
    }
    _contractMethodCreateAccessList(abi, params, errorsAbi, options, block) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const tx = (0, utils_1.getCreateAccessListParams)({
                abi,
                params,
                options,
                contractOptions: Object.assign(Object.assign({}, this.options), { from: (_a = this.options.from) !== null && _a !== void 0 ? _a : this.getConfig().defaultAccount }),
            });
            try {
                return (0, web3_eth_1.createAccessList)(this, tx, block, web3_utils_1.DEFAULT_RETURN_FORMAT);
            }
            catch (error) {
                if (error instanceof web3_errors_1.ContractExecutionError) {
                    (0, web3_eth_abi_1.decodeContractErrorData)(errorsAbi, error.innerError);
                }
                throw error;
            }
        });
    }
    _contractMethodSend(abi, params, errorsAbi, options, contractOptions) {
        var _a, _b;
        let modifiedContractOptions = contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options;
        modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), { data: undefined, from: (_b = (_a = modifiedContractOptions.from) !== null && _a !== void 0 ? _a : this.defaultAccount) !== null && _b !== void 0 ? _b : undefined });
        const tx = (0, utils_1.getSendTxParams)({
            abi,
            params,
            options,
            contractOptions: modifiedContractOptions,
        });
        const transactionToSend = (0, web3_eth_1.sendTransaction)(this, tx, web3_utils_1.DEFAULT_RETURN_FORMAT, {
            checkRevertBeforeSending: false,
        });
        void transactionToSend.on('error', (error) => {
            if (error instanceof web3_errors_1.ContractExecutionError) {
                (0, web3_eth_abi_1.decodeContractErrorData)(errorsAbi, error.innerError);
            }
        });
        return transactionToSend;
    }
    _contractMethodDeploySend(abi, params, options, contractOptions) {
        var _a, _b;
        let modifiedContractOptions = contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options;
        modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), { from: (_b = (_a = modifiedContractOptions.from) !== null && _a !== void 0 ? _a : this.defaultAccount) !== null && _b !== void 0 ? _b : undefined });
        const tx = (0, utils_1.getSendTxParams)({
            abi,
            params,
            options,
            contractOptions: modifiedContractOptions,
        });
        return (0, web3_eth_1.sendTransaction)(this, tx, web3_utils_1.DEFAULT_RETURN_FORMAT, {
            transactionResolver: receipt => {
                if (receipt.status === BigInt(0)) {
                    throw new web3_errors_1.Web3ContractError("code couldn't be stored", receipt);
                }
                const newContract = this.clone();
                newContract.options.address = receipt.contractAddress;
                return newContract;
            },
            checkRevertBeforeSending: false,
        });
    }
    _contractMethodEstimateGas({ abi, params, returnFormat, options, contractOptions, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = (0, utils_1.getEstimateGasParams)({
                abi,
                params,
                options,
                contractOptions: contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options,
            });
            return (0, web3_eth_1.estimateGas)(this, tx, web3_types_1.BlockTags.LATEST, returnFormat);
        });
    }
    _createContractEvent(abi, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) {
        return (...params) => {
            var _a;
            const { topics, fromBlock } = (0, encoding_1.encodeEventABI)(this.options, abi, params[0]);
            const sub = new log_subscription_1.LogsSubscription({
                address: this.options.address,
                topics,
                abi,
                jsonInterface: this._jsonInterface,
            }, { requestManager: this.requestManager, returnFormat });
            if (!(0, web3_validator_1.isNullish)(fromBlock)) {
                this.getPastEvents(abi.name, { fromBlock, topics }, returnFormat)
                    .then(logs => {
                    logs.forEach(log => sub.emit('data', log));
                })
                    .catch(() => {
                    sub.emit('error', new web3_errors_1.SubscriptionError('Failed to get past events.'));
                });
            }
            (_a = this.subscriptionManager) === null || _a === void 0 ? void 0 : _a.addSubscription(sub).catch(() => {
                sub.emit('error', new web3_errors_1.SubscriptionError('Failed to subscribe.'));
            });
            return sub;
        };
    }
    subscribeToContextEvents(context) {
        const contractThis = this;
        this.context = context;
        if (contractThis.syncWithContext) {
            context.on(web3_core_1.Web3ConfigEvent.CONFIG_CHANGE, event => {
                contractThis.setConfig({ [event.name]: event.newValue });
            });
        }
    }
}
exports.Contract = Contract;
//# sourceMappingURL=contract.js.map