import { Web3Context, Web3EventEmitter, Web3PromiEvent } from 'web3-core';
import { NewHeadsSubscription, SendTransactionEvents } from 'web3-eth';
import { AbiFunctionFragment, ContractAbi, ContractConstructorArgs, ContractEvent, ContractEvents, ContractMethod, ContractMethodInputParameters, ContractMethodOutputParameters, Address, EthExecutionAPI, Filter, FilterAbis, HexString } from 'web3-types';
import { DataFormat, DEFAULT_RETURN_FORMAT } from 'web3-utils';
import { LogsSubscription } from './log_subscription';
import { ContractEventOptions, ContractInitOptions, ContractOptions, EventLog, NonPayableMethodObject, PayableCallOptions, PayableMethodObject, PayableTxOptions, Web3ContractContext } from './types';
declare type ContractBoundMethod<Abi extends AbiFunctionFragment, Method extends ContractMethod<Abi> = ContractMethod<Abi>> = (...args: Method['Inputs']) => Method['Abi']['stateMutability'] extends 'payable' | 'pure' ? PayableMethodObject<Method['Inputs'], Method['Outputs']> : NonPayableMethodObject<Method['Inputs'], Method['Outputs']>;
export declare type ContractOverloadedMethodInputs<AbiArr extends ReadonlyArray<unknown>> = NonNullable<AbiArr extends readonly [] ? undefined : AbiArr extends readonly [infer A, ...infer R] ? A extends AbiFunctionFragment ? ContractMethodInputParameters<A['inputs']> | ContractOverloadedMethodInputs<R> : undefined : undefined>;
export declare type ContractOverloadedMethodOutputs<AbiArr extends ReadonlyArray<unknown>> = NonNullable<AbiArr extends readonly [] ? undefined : AbiArr extends readonly [infer A, ...infer R] ? A extends AbiFunctionFragment ? ContractMethodOutputParameters<A['outputs']> | ContractOverloadedMethodOutputs<R> : undefined : undefined>;
export declare type ContractMethodsInterface<Abi extends ContractAbi> = {
    [MethodAbi in FilterAbis<Abi, AbiFunctionFragment & {
        type: 'function';
    }> as MethodAbi['name']]: ContractBoundMethod<MethodAbi>;
} & {
    [key: string]: ContractBoundMethod<any>;
};
export declare type ContractBoundEvent = (options?: ContractEventOptions) => LogsSubscription;
export declare type ContractEventsInterface<Abi extends ContractAbi, Events extends ContractEvents<Abi> = ContractEvents<Abi>> = {
    [Name in keyof Events | 'allEvents']: ContractBoundEvent;
} & {
    [key: string]: ContractBoundEvent;
};
export declare type ContractEventEmitterInterface<Abi extends ContractAbi> = {
    [EventAbi in FilterAbis<Abi, AbiFunctionFragment & {
        type: 'event';
    }> as EventAbi['name']]: ContractEvent<EventAbi>['Inputs'];
};
declare const contractSubscriptions: {
    logs: typeof LogsSubscription;
    newHeads: typeof NewHeadsSubscription;
    newBlockHeaders: typeof NewHeadsSubscription;
};
export declare class Contract<Abi extends ContractAbi> extends Web3Context<EthExecutionAPI, typeof contractSubscriptions> implements Web3EventEmitter<ContractEventEmitterInterface<Abi>> {
    readonly options: ContractOptions;
    syncWithContext: boolean;
    private _errorsInterface;
    private _jsonInterface;
    private _address?;
    private _functions;
    private readonly _overloadedMethodAbis;
    private _methods;
    private _events;
    private context?;
    constructor(jsonInterface: Abi, context?: Web3ContractContext | Web3Context, returnFormat?: DataFormat);
    constructor(jsonInterface: Abi, address?: Address, contextOrReturnFormat?: Web3ContractContext | Web3Context | DataFormat, returnFormat?: DataFormat);
    constructor(jsonInterface: Abi, options?: ContractInitOptions, contextOrReturnFormat?: Web3ContractContext | Web3Context | DataFormat, returnFormat?: DataFormat);
    constructor(jsonInterface: Abi, address: Address | undefined, options: ContractInitOptions, contextOrReturnFormat?: Web3ContractContext | Web3Context | DataFormat, returnFormat?: DataFormat);
    get events(): ContractEventsInterface<Abi, ContractEvents<Abi>>;
    get methods(): ContractMethodsInterface<Abi>;
    clone(): Contract<any>;
    deploy(deployOptions?: {
        data?: HexString;
        arguments?: ContractConstructorArgs<Abi>;
    }): {
        arguments: never[] | NonNullable<ContractConstructorArgs<Abi>>;
        send: (options?: PayableTxOptions) => Web3PromiEvent<Contract<Abi>, SendTransactionEvents<typeof DEFAULT_RETURN_FORMAT>>;
        estimateGas: <ReturnFormat extends DataFormat = {
            readonly number: import("web3-utils").FMT_NUMBER.BIGINT;
            readonly bytes: import("web3-utils").FMT_BYTES.HEX;
        }>(options?: PayableCallOptions, returnFormat?: ReturnFormat) => Promise<import("web3-utils").NumberTypes[ReturnFormat["number"]]>;
        encodeABI: () => string;
    };
    getPastEvents<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(returnFormat?: ReturnFormat): Promise<(string | EventLog)[]>;
    getPastEvents<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(eventName: keyof ContractEvents<Abi> | 'allEvents', returnFormat?: ReturnFormat): Promise<(string | EventLog)[]>;
    getPastEvents<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(filter: Omit<Filter, 'address'>, returnFormat?: ReturnFormat): Promise<(string | EventLog)[]>;
    getPastEvents<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(eventName: keyof ContractEvents<Abi> | 'allEvents', filter: Omit<Filter, 'address'>, returnFormat?: ReturnFormat): Promise<(string | EventLog)[]>;
    private _parseAndSetAddress;
    private _parseAndSetJsonInterface;
    private _getAbiParams;
    private _createContractMethod;
    private _contractMethodCall;
    private _contractMethodCreateAccessList;
    private _contractMethodSend;
    private _contractMethodDeploySend;
    private _contractMethodEstimateGas;
    private _createContractEvent;
    protected subscribeToContextEvents<T extends Web3Context>(context: T): void;
}
export {};
//# sourceMappingURL=contract.d.ts.map