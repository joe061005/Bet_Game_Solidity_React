"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonInterfaceMethodToString = exports.flattenTypes = exports.modifyParams = exports.formatParam = exports.formatOddHexstrings = exports.isOddHexstring = exports.mapTypes = exports.mapStructToCoderFormat = exports.mapStructNameAndType = exports.isSimplifiedStructFormat = exports.isAbiConstructorFragment = exports.isAbiFunctionFragment = exports.isAbiEventFragment = exports.isAbiErrorFragment = exports.isAbiFragment = void 0;
const web3_errors_1 = require("web3-errors");
const abi_1 = require("@ethersproject/abi");
const web3_utils_1 = require("web3-utils");
const ethers_abi_coder_1 = __importDefault(require("./ethers_abi_coder"));
const isAbiFragment = (item) => !(0, web3_utils_1.isNullish)(item) &&
    typeof item === 'object' &&
    !(0, web3_utils_1.isNullish)(item.type) &&
    ['function', 'event', 'constructor', 'error'].includes(item.type);
exports.isAbiFragment = isAbiFragment;
const isAbiErrorFragment = (item) => !(0, web3_utils_1.isNullish)(item) &&
    typeof item === 'object' &&
    !(0, web3_utils_1.isNullish)(item.type) &&
    item.type === 'error';
exports.isAbiErrorFragment = isAbiErrorFragment;
const isAbiEventFragment = (item) => !(0, web3_utils_1.isNullish)(item) &&
    typeof item === 'object' &&
    !(0, web3_utils_1.isNullish)(item.type) &&
    item.type === 'event';
exports.isAbiEventFragment = isAbiEventFragment;
const isAbiFunctionFragment = (item) => !(0, web3_utils_1.isNullish)(item) &&
    typeof item === 'object' &&
    !(0, web3_utils_1.isNullish)(item.type) &&
    item.type === 'function';
exports.isAbiFunctionFragment = isAbiFunctionFragment;
const isAbiConstructorFragment = (item) => !(0, web3_utils_1.isNullish)(item) &&
    typeof item === 'object' &&
    !(0, web3_utils_1.isNullish)(item.type) &&
    item.type === 'constructor';
exports.isAbiConstructorFragment = isAbiConstructorFragment;
const isSimplifiedStructFormat = (type) => typeof type === 'object' &&
    typeof type.components === 'undefined' &&
    typeof type.name === 'undefined';
exports.isSimplifiedStructFormat = isSimplifiedStructFormat;
const mapStructNameAndType = (structName) => structName.includes('[]')
    ? { type: 'tuple[]', name: structName.slice(0, -2) }
    : { type: 'tuple', name: structName };
exports.mapStructNameAndType = mapStructNameAndType;
const mapStructToCoderFormat = (struct) => {
    const components = [];
    for (const key of Object.keys(struct)) {
        const item = struct[key];
        if (typeof item === 'object') {
            components.push(Object.assign(Object.assign({}, (0, exports.mapStructNameAndType)(key)), { components: (0, exports.mapStructToCoderFormat)(item) }));
        }
        else {
            components.push({
                name: key,
                type: struct[key],
            });
        }
    }
    return components;
};
exports.mapStructToCoderFormat = mapStructToCoderFormat;
const mapTypes = (types) => {
    const mappedTypes = [];
    for (const type of types) {
        let modifiedType = type;
        if (typeof type === 'object') {
            modifiedType = Object.assign({}, type);
        }
        if (typeof type === 'object' && type.type === 'function') {
            modifiedType = Object.assign(Object.assign({}, type), { type: 'bytes24' });
        }
        if ((0, exports.isSimplifiedStructFormat)(modifiedType)) {
            const structName = Object.keys(modifiedType)[0];
            mappedTypes.push(Object.assign(Object.assign({}, (0, exports.mapStructNameAndType)(structName)), { components: (0, exports.mapStructToCoderFormat)(modifiedType[structName]) }));
        }
        else {
            mappedTypes.push(modifiedType);
        }
    }
    return mappedTypes;
};
exports.mapTypes = mapTypes;
const isOddHexstring = (param) => typeof param === 'string' && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;
exports.isOddHexstring = isOddHexstring;
const formatOddHexstrings = (param) => (0, exports.isOddHexstring)(param) ? `0x0${param.substring(2)}` : param;
exports.formatOddHexstrings = formatOddHexstrings;
const formatParam = (type, _param) => {
    var _a;
    const param = typeof _param === 'object' && !Array.isArray(_param) ? Object.assign({}, _param) : _param;
    const paramTypeBytes = /^bytes([0-9]*)$/;
    const paramTypeBytesArray = /^bytes([0-9]*)\[\]$/;
    const paramTypeNumber = /^(u?int)([0-9]*)$/;
    const paramTypeNumberArray = /^(u?int)([0-9]*)\[\]$/;
    if (param instanceof BigInt) {
        return param.toString(10);
    }
    if (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {
        const paramClone = [...param];
        return paramClone.map(p => (0, exports.formatParam)(type.replace('[]', ''), p));
    }
    let match = paramTypeNumber.exec(type);
    if (match) {
        const size = parseInt((_a = match[2]) !== null && _a !== void 0 ? _a : '256', 10);
        if (size / 8 < param.length) {
            return (0, web3_utils_1.leftPad)(param, size);
        }
    }
    match = paramTypeBytes.exec(type);
    if (match) {
        const hexParam = Buffer.isBuffer(param) ? (0, web3_utils_1.toHex)(param) : param;
        const size = parseInt(match[1], 10);
        if (size) {
            let maxSize = size * 2;
            if (param.startsWith('0x')) {
                maxSize += 2;
            }
            const paddedParam = hexParam.length < maxSize
                ? (0, web3_utils_1.rightPad)(param, size * 2)
                : hexParam;
            return (0, exports.formatOddHexstrings)(paddedParam);
        }
        return (0, exports.formatOddHexstrings)(hexParam);
    }
    return param;
};
exports.formatParam = formatParam;
const modifyParams = (coder, param) => {
    if (coder.name === 'array') {
        return param.map(p => (0, exports.modifyParams)(ethers_abi_coder_1.default._getCoder(abi_1.ParamType.from(coder.type.replace('[]', ''))), [
            p,
        ]));
    }
    coder.coders.forEach((c, i) => {
        if (c.name === 'tuple') {
            (0, exports.modifyParams)(c, [param[i]]);
        }
        else {
            param[i] = (0, exports.formatParam)(c.name, param[i]);
        }
    });
    return [];
};
exports.modifyParams = modifyParams;
const flattenTypes = (includeTuple, puts) => {
    const types = [];
    puts.forEach(param => {
        if (typeof param.components === 'object') {
            if (!param.type.startsWith('tuple')) {
                throw new web3_errors_1.AbiError(`Invalid value given "${param.type}". Error: components found but type is not tuple.`);
            }
            const arrayBracket = param.type.indexOf('[');
            const suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : '';
            const result = (0, exports.flattenTypes)(includeTuple, param.components);
            if (Array.isArray(result) && includeTuple) {
                types.push(`tuple(${result.join(',')})${suffix}`);
            }
            else if (!includeTuple) {
                types.push(`(${result.join(',')})${suffix}`);
            }
            else {
                types.push(`(${result.join()})`);
            }
        }
        else {
            types.push(param.type);
        }
    });
    return types;
};
exports.flattenTypes = flattenTypes;
const jsonInterfaceMethodToString = (json) => {
    var _a, _b, _c, _d;
    if ((0, exports.isAbiErrorFragment)(json) || (0, exports.isAbiEventFragment)(json) || (0, exports.isAbiFunctionFragment)(json)) {
        if ((_a = json.name) === null || _a === void 0 ? void 0 : _a.includes('(')) {
            return json.name;
        }
        return `${(_b = json.name) !== null && _b !== void 0 ? _b : ''}(${(0, exports.flattenTypes)(false, (_c = json.inputs) !== null && _c !== void 0 ? _c : []).join(',')})`;
    }
    return `(${(0, exports.flattenTypes)(false, (_d = json.inputs) !== null && _d !== void 0 ? _d : []).join(',')})`;
};
exports.jsonInterfaceMethodToString = jsonInterfaceMethodToString;
//# sourceMappingURL=utils.js.map