"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeParameter = exports.decodeParameters = exports.decodeParametersWith = exports.encodeParameter = exports.encodeParameters = void 0;
const web3_errors_1 = require("web3-errors");
const abi_1 = require("@ethersproject/abi");
const ethers_abi_coder_1 = __importDefault(require("../ethers_abi_coder"));
const utils_1 = require("../utils");
const formatDecodedObject = (abi, input) => {
    let index = 0;
    const res = {};
    for (const j of Object.keys(abi)) {
        if (typeof abi[j] === 'string') {
            res[j] = input[j];
            res[index] = input[j];
        }
        if (typeof abi[j] === 'object') {
            res[j] = formatDecodedObject(abi[j], input[j]);
            res[index] = res[j];
        }
        index += 1;
    }
    return res;
};
const encodeParameters = (abi, params) => {
    try {
        const modifiedTypes = (0, utils_1.mapTypes)(Array.isArray(abi) ? abi : [abi]);
        const modifiedParams = [];
        for (const [index, param] of params.entries()) {
            const item = modifiedTypes[index];
            let type;
            if ((0, utils_1.isAbiFragment)(item) && item.type) {
                type = item.type;
            }
            else {
                type = item;
            }
            const newParam = (0, utils_1.formatParam)(type, param);
            if (typeof type === 'string' && type.includes('tuple')) {
                const coder = ethers_abi_coder_1.default._getCoder(abi_1.ParamType.from(type));
                (0, utils_1.modifyParams)(coder, [newParam]);
            }
            modifiedParams.push(newParam);
        }
        return ethers_abi_coder_1.default.encode(modifiedTypes.map(p => abi_1.ParamType.from(p)), modifiedParams);
    }
    catch (err) {
        throw new web3_errors_1.AbiError(`Parameter encoding error`, err);
    }
};
exports.encodeParameters = encodeParameters;
const encodeParameter = (abi, param) => (0, exports.encodeParameters)([abi], [param]);
exports.encodeParameter = encodeParameter;
const isParamRequiredToConvert = (data) => Array.isArray(data) &&
    Object.keys(data).filter(k => Number.isInteger(+k)).length !== Object.keys(data).length;
const formatArrayResToObject = (data) => {
    const returnValue = {
        __length__: 0,
    };
    for (const key of Object.keys(data)) {
        returnValue[key] =
            Array.isArray(data[key]) && isParamRequiredToConvert(data[key])
                ? formatArrayResToObject(data[key])
                : data[key];
        returnValue.__length__ += Number.isInteger(+key) ? 1 : 0;
    }
    return returnValue;
};
const decodeParametersWith = (abis, bytes, loose) => {
    try {
        if (abis.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {
            throw new web3_errors_1.AbiError("Returned values aren't valid, did it run Out of Gas? " +
                'You might also see this error if you are not using the ' +
                'correct ABI for the contract you are retrieving data from, ' +
                'requesting data from a block number that does not exist, ' +
                'or querying a node which is not fully synced.');
        }
        const res = ethers_abi_coder_1.default.decode((0, utils_1.mapTypes)(abis).map(p => abi_1.ParamType.from(p)), `0x${bytes.replace(/0x/i, '')}`, loose);
        return formatArrayResToObject(res);
    }
    catch (err) {
        throw new web3_errors_1.AbiError(`Parameter decoding error: ${err.message}`);
    }
};
exports.decodeParametersWith = decodeParametersWith;
const decodeParameters = (abi, bytes) => (0, exports.decodeParametersWith)(abi, bytes, false);
exports.decodeParameters = decodeParameters;
const decodeParameter = (abi, bytes) => (0, exports.decodeParameters)([abi], bytes)['0'];
exports.decodeParameter = decodeParameter;
//# sourceMappingURL=parameters_api.js.map