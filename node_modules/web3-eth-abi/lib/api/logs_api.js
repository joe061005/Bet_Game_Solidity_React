"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeLog = void 0;
const parameters_api_1 = require("./parameters_api");
const STATIC_TYPES = ['bool', 'string', 'int', 'uint', 'address', 'fixed', 'ufixed'];
const decodeLog = (inputs, data, topics) => {
    const clonedTopics = Array.isArray(topics) ? topics : [topics];
    const indexedInputs = {};
    const nonIndexedInputs = {};
    for (const [i, input] of inputs.entries()) {
        if (input.indexed) {
            indexedInputs[i] = input;
        }
        else {
            nonIndexedInputs[i] = input;
        }
    }
    const decodedNonIndexedInputs = data
        ? (0, parameters_api_1.decodeParametersWith)(Object.values(nonIndexedInputs), data, true)
        : { __length__: 0 };
    const offset = clonedTopics.length - Object.keys(indexedInputs).length;
    const decodedIndexedInputs = Object.values(indexedInputs).map((input, index) => STATIC_TYPES.some(s => input.type.startsWith(s))
        ? (0, parameters_api_1.decodeParameter)(input.type, clonedTopics[index + offset])
        : clonedTopics[index + offset]);
    const returnValues = { __length__: 0 };
    let indexedCounter = 0;
    let nonIndexedCounter = 0;
    for (const [i, res] of inputs.entries()) {
        returnValues[i] = res.type === 'string' ? '' : undefined;
        if (indexedInputs[i]) {
            returnValues[i] = decodedIndexedInputs[indexedCounter];
            indexedCounter += 1;
        }
        if (nonIndexedInputs[i]) {
            returnValues[i] = decodedNonIndexedInputs[String(nonIndexedCounter)];
            nonIndexedCounter += 1;
        }
        if (res.name) {
            returnValues[res.name] = returnValues[i];
        }
        returnValues.__length__ += 1;
    }
    return returnValues;
};
exports.decodeLog = decodeLog;
//# sourceMappingURL=logs_api.js.map