"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = void 0;
const web3_types_1 = require("web3-types");
const web3_validator_1 = require("web3-validator");
class Wallet extends web3_types_1.Web3BaseWallet {
    constructor() {
        super(...arguments);
        this._addressMap = new Map();
        this._defaultKeyName = 'web3js_wallet';
    }
    static getStorage() {
        let storage;
        try {
            storage = window.localStorage;
            const x = '__storage_test__';
            storage.setItem(x, x);
            storage.removeItem(x);
            return storage;
        }
        catch (e) {
            return e &&
                (e.code === 22 ||
                    e.code === 1014 ||
                    e.name === 'QuotaExceededError' ||
                    e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
                !(0, web3_validator_1.isNullish)(storage) &&
                storage.length !== 0
                ? storage
                : undefined;
        }
    }
    create(numberOfAccounts) {
        for (let i = 0; i < numberOfAccounts; i += 1) {
            this.add(this._accountProvider.create());
        }
        return this;
    }
    add(account) {
        var _a;
        if (typeof account === 'string') {
            return this.add(this._accountProvider.privateKeyToAccount(account));
        }
        let index = this.length;
        const existAccount = this.get(account.address);
        if (existAccount) {
            console.warn(`Account ${account.address.toLowerCase()} already exists.`);
            index = (_a = this._addressMap.get(account.address.toLowerCase())) !== null && _a !== void 0 ? _a : index;
        }
        this._addressMap.set(account.address.toLowerCase(), index);
        this[index] = account;
        return this;
    }
    get(addressOrIndex) {
        if (typeof addressOrIndex === 'string') {
            const index = this._addressMap.get(addressOrIndex.toLowerCase());
            if (!(0, web3_validator_1.isNullish)(index)) {
                return this[index];
            }
            return undefined;
        }
        return this[addressOrIndex];
    }
    remove(addressOrIndex) {
        if (typeof addressOrIndex === 'string') {
            const index = this._addressMap.get(addressOrIndex.toLowerCase());
            if ((0, web3_validator_1.isNullish)(index)) {
                return false;
            }
            this._addressMap.delete(addressOrIndex.toLowerCase());
            this.splice(index, 1);
            return true;
        }
        if (this[addressOrIndex]) {
            this.splice(addressOrIndex, 1);
            return true;
        }
        return false;
    }
    clear() {
        this._addressMap.clear();
        this.length = 0;
        return this;
    }
    encrypt(password, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(this.map((account) => __awaiter(this, void 0, void 0, function* () { return account.encrypt(password, options); })));
        });
    }
    decrypt(encryptedWallets, password, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Promise.all(encryptedWallets.map((wallet) => __awaiter(this, void 0, void 0, function* () { return this._accountProvider.decrypt(wallet, password, options); })));
            for (const res of results) {
                this.add(res);
            }
            return this;
        });
    }
    save(password, keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = Wallet.getStorage();
            if (!storage) {
                throw new Error('Local storage not available.');
            }
            storage.setItem(keyName !== null && keyName !== void 0 ? keyName : this._defaultKeyName, JSON.stringify(yield this.encrypt(password)));
            return true;
        });
    }
    load(password, keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = Wallet.getStorage();
            if (!storage) {
                throw new Error('Local storage not available.');
            }
            const keystore = storage.getItem(keyName !== null && keyName !== void 0 ? keyName : this._defaultKeyName);
            if (keystore) {
                yield this.decrypt(JSON.parse(keystore) || [], password);
            }
            return this;
        });
    }
}
exports.Wallet = Wallet;
//# sourceMappingURL=wallet.js.map