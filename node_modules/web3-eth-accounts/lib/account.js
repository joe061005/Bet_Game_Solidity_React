"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decrypt = exports.create = exports.privateKeyToAccount = exports.encrypt = exports.privateKeyToAddress = exports.recover = exports.recoverTransaction = exports.signTransaction = exports.sign = exports.hashMessage = exports.parseAndValidatePrivateKey = void 0;
const tx_1 = require("@ethereumjs/tx");
const aes_1 = require("ethereum-cryptography/aes");
const pbkdf2_1 = require("ethereum-cryptography/pbkdf2");
const scrypt_1 = require("ethereum-cryptography/scrypt");
const secp256k1_1 = require("ethereum-cryptography/secp256k1");
const web3_errors_1 = require("web3-errors");
const web3_utils_1 = require("web3-utils");
const web3_validator_1 = require("web3-validator");
const schemas_1 = require("./schemas");
const parseAndValidatePrivateKey = (data, ignoreLength) => {
    let privateKeyBuffer;
    if (!ignoreLength && typeof data === 'string' && (0, web3_utils_1.isHexStrict)(data) && data.length !== 66) {
        throw new web3_errors_1.PrivateKeyLengthError();
    }
    try {
        privateKeyBuffer = Buffer.isBuffer(data) ? data : (0, web3_utils_1.bytesToBuffer)(data);
    }
    catch (_a) {
        throw new web3_errors_1.InvalidPrivateKeyError();
    }
    if (!ignoreLength && privateKeyBuffer.byteLength !== 32) {
        throw new web3_errors_1.PrivateKeyLengthError();
    }
    return privateKeyBuffer;
};
exports.parseAndValidatePrivateKey = parseAndValidatePrivateKey;
const hashMessage = (message) => {
    const messageHex = (0, web3_utils_1.isHexStrict)(message) ? message : (0, web3_utils_1.utf8ToHex)(message);
    const messageBytes = (0, web3_utils_1.hexToBytes)(messageHex);
    const preamble = Buffer.from(`\x19Ethereum Signed Message:\n${messageBytes.byteLength}`, 'utf8');
    const ethMessage = Buffer.concat([preamble, messageBytes]);
    return (0, web3_utils_1.sha3Raw)(ethMessage);
};
exports.hashMessage = hashMessage;
const sign = (data, privateKey) => {
    const privateKeyBuffer = (0, exports.parseAndValidatePrivateKey)(privateKey);
    const hash = (0, exports.hashMessage)(data);
    const [signature, recoverId] = (0, secp256k1_1.signSync)(hash.substring(2), privateKeyBuffer, {
        recovered: true,
        der: false,
    });
    const r = Buffer.from(signature.slice(0, 32));
    const s = Buffer.from(signature.slice(32, 64));
    const v = recoverId + 27;
    return {
        message: data,
        messageHash: hash,
        v: (0, web3_utils_1.numberToHex)(v),
        r: (0, web3_utils_1.bytesToHex)(r),
        s: (0, web3_utils_1.bytesToHex)(s),
        signature: `0x${Buffer.from(signature).toString('hex')}${v.toString(16)}`,
    };
};
exports.sign = sign;
const signTransaction = (transaction, privateKey) => __awaiter(void 0, void 0, void 0, function* () {
    const signedTx = transaction.sign(Buffer.from(privateKey.substring(2), 'hex'));
    if ((0, web3_validator_1.isNullish)(signedTx.v) || (0, web3_validator_1.isNullish)(signedTx.r) || (0, web3_validator_1.isNullish)(signedTx.s))
        throw new web3_errors_1.TransactionSigningError('Signer Error');
    const validationErrors = signedTx.validate(true);
    if (validationErrors.length > 0) {
        let errorString = 'Signer Error ';
        for (const validationError of validationErrors) {
            errorString += `${errorString} ${validationError}.`;
        }
        throw new web3_errors_1.TransactionSigningError(errorString);
    }
    const rawTx = (0, web3_utils_1.bytesToHex)(signedTx.serialize());
    const txHash = (0, web3_utils_1.sha3Raw)(rawTx);
    return {
        messageHash: (0, web3_utils_1.bytesToHex)(Buffer.from(signedTx.getMessageToSign(true))),
        v: `0x${signedTx.v.toString('hex')}`,
        r: `0x${signedTx.r.toString('hex')}`,
        s: `0x${signedTx.s.toString('hex')}`,
        rawTransaction: rawTx,
        transactionHash: (0, web3_utils_1.bytesToHex)(txHash),
    };
});
exports.signTransaction = signTransaction;
const recoverTransaction = (rawTransaction) => {
    if ((0, web3_validator_1.isNullish)(rawTransaction))
        throw new web3_errors_1.UndefinedRawTransactionError();
    const tx = tx_1.TransactionFactory.fromSerializedData(Buffer.from(rawTransaction.slice(2), 'hex'));
    return (0, web3_utils_1.toChecksumAddress)(tx.getSenderAddress().toString());
};
exports.recoverTransaction = recoverTransaction;
const recover = (data, signatureOrV, prefixedOrR, s, prefixed) => {
    if (typeof data === 'object') {
        const signatureStr = `${data.r}${data.s.slice(2)}${data.v.slice(2)}`;
        return (0, exports.recover)(data.messageHash, signatureStr, prefixedOrR);
    }
    if (typeof signatureOrV === 'string' && typeof prefixedOrR === 'string' && !(0, web3_validator_1.isNullish)(s)) {
        const signatureStr = `${prefixedOrR}${s.slice(2)}${signatureOrV.slice(2)}`;
        return (0, exports.recover)(data, signatureStr, prefixed);
    }
    if ((0, web3_validator_1.isNullish)(signatureOrV))
        throw new web3_errors_1.InvalidSignatureError('signature string undefined');
    const V_INDEX = 130;
    const hashedMessage = prefixedOrR ? data : (0, exports.hashMessage)(data);
    const v = signatureOrV.substring(V_INDEX);
    const ecPublicKey = (0, secp256k1_1.recoverPublicKey)(Buffer.from(hashedMessage.substring(2), 'hex'), Buffer.from(signatureOrV.substring(2, V_INDEX), 'hex'), parseInt(v, 16) - 27, false);
    const publicKey = `0x${Buffer.from(ecPublicKey).toString('hex').slice(2)}`;
    const publicHash = (0, web3_utils_1.sha3Raw)(publicKey);
    const address = (0, web3_utils_1.toChecksumAddress)(`0x${publicHash.slice(-40)}`);
    return address;
};
exports.recover = recover;
const privateKeyToAddress = (privateKey) => {
    const privateKeyBuffer = (0, exports.parseAndValidatePrivateKey)(privateKey);
    const publicKey = (0, secp256k1_1.getPublicKey)(privateKeyBuffer);
    const publicKeyHash = (0, web3_utils_1.sha3Raw)(publicKey.slice(1));
    const address = publicKeyHash.slice(-40);
    return (0, web3_utils_1.toChecksumAddress)(`0x${address}`);
};
exports.privateKeyToAddress = privateKeyToAddress;
const encrypt = (privateKey, password, options) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g;
    const privateKeyBuffer = (0, exports.parseAndValidatePrivateKey)(privateKey);
    let salt;
    if (options === null || options === void 0 ? void 0 : options.salt) {
        salt = typeof options.salt === 'string' ? Buffer.from(options.salt, 'hex') : options.salt;
    }
    else {
        salt = (0, web3_utils_1.randomBytes)(32);
    }
    if (!((0, web3_validator_1.isString)(password) || (0, web3_validator_1.isBuffer)(password))) {
        throw new web3_errors_1.InvalidPasswordError();
    }
    const bufferPassword = typeof password === 'string' ? Buffer.from(password) : password;
    let initializationVector;
    if (options === null || options === void 0 ? void 0 : options.iv) {
        initializationVector =
            typeof options.iv === 'string' ? Buffer.from(options.iv, 'hex') : options.iv;
        if (initializationVector.toString('hex').length !== 32) {
            throw new web3_errors_1.IVLengthError();
        }
    }
    else {
        initializationVector = (0, web3_utils_1.randomBytes)(16);
    }
    const kdf = (_a = options === null || options === void 0 ? void 0 : options.kdf) !== null && _a !== void 0 ? _a : 'scrypt';
    let derivedKey;
    let kdfparams;
    if (kdf === 'pbkdf2') {
        kdfparams = {
            dklen: (_b = options === null || options === void 0 ? void 0 : options.dklen) !== null && _b !== void 0 ? _b : 32,
            salt: salt.toString('hex'),
            c: (_c = options === null || options === void 0 ? void 0 : options.c) !== null && _c !== void 0 ? _c : 262144,
            prf: 'hmac-sha256',
        };
        if (kdfparams.c < 1000) {
            throw new web3_errors_1.PBKDF2IterationsError();
        }
        derivedKey = (0, pbkdf2_1.pbkdf2Sync)(bufferPassword, Buffer.from(salt), kdfparams.c, kdfparams.dklen, 'sha256');
    }
    else if (kdf === 'scrypt') {
        kdfparams = {
            n: (_d = options === null || options === void 0 ? void 0 : options.n) !== null && _d !== void 0 ? _d : 8192,
            r: (_e = options === null || options === void 0 ? void 0 : options.r) !== null && _e !== void 0 ? _e : 8,
            p: (_f = options === null || options === void 0 ? void 0 : options.p) !== null && _f !== void 0 ? _f : 1,
            dklen: (_g = options === null || options === void 0 ? void 0 : options.dklen) !== null && _g !== void 0 ? _g : 32,
            salt: salt.toString('hex'),
        };
        derivedKey = (0, scrypt_1.scryptSync)(bufferPassword, Buffer.from(salt), kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);
    }
    else {
        throw new web3_errors_1.InvalidKdfError();
    }
    const cipher = yield (0, aes_1.encrypt)(privateKeyBuffer, Buffer.from(derivedKey.slice(0, 16)), initializationVector, 'aes-128-ctr');
    const ciphertext = (0, web3_utils_1.bytesToHex)(cipher).slice(2);
    const mac = (0, web3_utils_1.sha3Raw)(Buffer.from([...derivedKey.slice(16, 32), ...cipher])).replace('0x', '');
    return {
        version: 3,
        id: (0, web3_utils_1.uuidV4)(),
        address: (0, exports.privateKeyToAddress)(privateKeyBuffer).toLowerCase().replace('0x', ''),
        crypto: {
            ciphertext,
            cipherparams: {
                iv: initializationVector.toString('hex'),
            },
            cipher: 'aes-128-ctr',
            kdf,
            kdfparams,
            mac,
        },
    };
});
exports.encrypt = encrypt;
const privateKeyToAccount = (privateKey, ignoreLength) => {
    const privateKeyBuffer = (0, exports.parseAndValidatePrivateKey)(privateKey, ignoreLength);
    return {
        address: (0, exports.privateKeyToAddress)(privateKeyBuffer),
        privateKey: (0, web3_utils_1.bytesToHex)(privateKeyBuffer),
        signTransaction: (_tx) => {
            throw new web3_errors_1.TransactionSigningError('Do not have network access to sign the transaction');
        },
        sign: (data) => (0, exports.sign)(typeof data === 'string' ? data : JSON.stringify(data), privateKeyBuffer),
        encrypt: (password, options) => __awaiter(void 0, void 0, void 0, function* () { return (0, exports.encrypt)(privateKeyBuffer, password, options); }),
    };
};
exports.privateKeyToAccount = privateKeyToAccount;
const create = () => {
    const privateKey = secp256k1_1.utils.randomPrivateKey();
    return (0, exports.privateKeyToAccount)(`0x${Buffer.from(privateKey).toString('hex')}`);
};
exports.create = create;
const decrypt = (keystore, password, nonStrict) => __awaiter(void 0, void 0, void 0, function* () {
    const json = typeof keystore === 'object'
        ? keystore
        : JSON.parse(nonStrict ? keystore.toLowerCase() : keystore);
    web3_validator_1.validator.validateJSONSchema(schemas_1.keyStoreSchema, json);
    if (json.version !== 3)
        throw new web3_errors_1.KeyStoreVersionError();
    const bufferPassword = typeof password === 'string' ? Buffer.from(password) : password;
    web3_validator_1.validator.validate(['bytes'], [bufferPassword]);
    let derivedKey;
    if (json.crypto.kdf === 'scrypt') {
        const kdfparams = json.crypto.kdfparams;
        const bufferSalt = typeof kdfparams.salt === 'string'
            ? Buffer.from(kdfparams.salt, 'hex')
            : kdfparams.salt;
        derivedKey = (0, scrypt_1.scryptSync)(bufferPassword, bufferSalt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);
    }
    else if (json.crypto.kdf === 'pbkdf2') {
        const kdfparams = json.crypto.kdfparams;
        const bufferSalt = typeof kdfparams.salt === 'string'
            ? Buffer.from(kdfparams.salt, 'hex')
            : kdfparams.salt;
        derivedKey = (0, pbkdf2_1.pbkdf2Sync)(bufferPassword, bufferSalt, kdfparams.c, kdfparams.dklen, 'sha256');
    }
    else {
        throw new web3_errors_1.InvalidKdfError();
    }
    const ciphertext = (0, web3_utils_1.hexToBytes)(`0X${json.crypto.ciphertext}`);
    const mac = (0, web3_utils_1.sha3Raw)(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');
    if (mac !== json.crypto.mac) {
        throw new web3_errors_1.KeyDerivationError();
    }
    const seed = yield (0, aes_1.decrypt)(Buffer.from(json.crypto.ciphertext, 'hex'), derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));
    return (0, exports.privateKeyToAccount)(Buffer.from(seed));
});
exports.decrypt = decrypt;
//# sourceMappingURL=account.js.map