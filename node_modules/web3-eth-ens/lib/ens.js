"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ENS = void 0;
const web3_eth_1 = require("web3-eth");
const web3_errors_1 = require("web3-errors");
const web3_core_1 = require("web3-core");
const web3_net_1 = require("web3-net");
const web3_utils_1 = require("web3-utils");
const registry_1 = require("./registry");
const config_1 = require("./config");
const resolver_1 = require("./resolver");
class ENS extends web3_core_1.Web3Context {
    constructor(registryAddr, provider) {
        super(provider !== null && provider !== void 0 ? provider : '');
        this.registryAddress = registryAddr !== null && registryAddr !== void 0 ? registryAddr : config_1.registryAddresses.main;
        this._registry = new registry_1.Registry(this.getContextObject(), registryAddr);
        this._resolver = new resolver_1.Resolver(this._registry);
    }
    getResolver(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.getResolver(name);
        });
    }
    setResolver(name, address, txConfig, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.setResolver(name, address, txConfig, returnFormat);
        });
    }
    setSubnodeRecord(name, label, owner, resolver, ttl, txConfig, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.setSubnodeRecord(name, label, owner, resolver, ttl, txConfig, returnFormat);
        });
    }
    setApprovalForAll(operator, approved, txConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.setApprovalForAll(operator, approved, txConfig);
        });
    }
    isApprovedForAll(owner, operator, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.isApprovedForAll(owner, operator, returnFormat);
        });
    }
    recordExists(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.recordExists(name);
        });
    }
    setSubnodeOwner(node, label, address, txConfig, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.setSubnodeOwner(node, label, address, txConfig, returnFormat);
        });
    }
    getTTL(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.getTTL(name);
        });
    }
    setTTL(name, ttl, txConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.setTTL(name, ttl, txConfig);
        });
    }
    getOwner(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.getOwner(name);
        });
    }
    setOwner(name, address, txConfig, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.setOwner(name, address, txConfig, returnFormat);
        });
    }
    setRecord(name, owner, resolver, ttl, txConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registry.setRecord(name, owner, resolver, ttl, txConfig);
        });
    }
    setAddress(name, address, txConfig, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._resolver.setAddress(name, address, txConfig, returnFormat);
        });
    }
    setPubkey(name, x, y, txConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._resolver.setPubkey(name, x, y, txConfig);
        });
    }
    setContenthash(name, hash, txConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._resolver.setContenthash(name, hash, txConfig);
        });
    }
    getAddress(ENSName, coinType = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._resolver.getAddress(ENSName, coinType);
        });
    }
    getPubkey(ENSName) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._resolver.getPubkey(ENSName);
        });
    }
    getContenthash(ENSName) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._resolver.getContenthash(ENSName);
        });
    }
    checkNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const now = Date.now() / 1000;
            if (!this._lastSyncCheck || now - this._lastSyncCheck > 3600) {
                const block = yield (0, web3_eth_1.getBlock)(this, 'latest', false, web3_utils_1.DEFAULT_RETURN_FORMAT);
                const headAge = BigInt(now) - BigInt(block.timestamp);
                if (headAge > 3600) {
                    throw new web3_errors_1.ENSNetworkNotSyncedError();
                }
                this._lastSyncCheck = now;
            }
            if (this._detectedAddress) {
                return this._detectedAddress;
            }
            const networkType = yield (0, web3_net_1.getId)(this, Object.assign(Object.assign({}, web3_utils_1.DEFAULT_RETURN_FORMAT), { number: web3_utils_1.FMT_NUMBER.HEX }));
            const addr = config_1.registryAddresses[networkType];
            if (typeof addr === 'undefined') {
                throw new web3_errors_1.ENSUnsupportedNetworkError(networkType);
            }
            this._detectedAddress = addr;
            return this._detectedAddress;
        });
    }
    supportsInterface(ENSName, interfaceId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._resolver.supportsInterface(ENSName, interfaceId);
        });
    }
    get events() {
        return this._registry.events;
    }
}
exports.ENS = ENS;
//# sourceMappingURL=ens.js.map