"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resolver = void 0;
const web3_utils_1 = require("web3-utils");
const web3_errors_1 = require("web3-errors");
const config_1 = require("./config");
const utils_1 = require("./utils");
class Resolver {
    constructor(registry) {
        this.registry = registry;
    }
    getResolverContractAdapter(ENSName) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.registry.getResolver(ENSName);
        });
    }
    checkInterfaceSupport(resolverContract, methodName) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if ((0, web3_utils_1.isNullish)(config_1.interfaceIds[methodName]))
                throw new web3_errors_1.ResolverMethodMissingError((_a = resolverContract.options.address) !== null && _a !== void 0 ? _a : '', methodName);
            const supported = yield resolverContract.methods
                .supportsInterface(config_1.interfaceIds[methodName])
                .call();
            if (!supported)
                throw new web3_errors_1.ResolverMethodMissingError((_b = resolverContract.options.address) !== null && _b !== void 0 ? _b : '', methodName);
        });
    }
    setAddress(ENSName, address, txConfig, returnFormat = web3_utils_1.DEFAULT_RETURN_FORMAT) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolverContract = yield this.getResolverContractAdapter(ENSName);
            yield this.checkInterfaceSupport(resolverContract, config_1.methodsInInterface.setAddr);
            return resolverContract.methods
                .setAddr((0, utils_1.namehash)(ENSName), (0, web3_utils_1.format)({ eth: 'address' }, address, returnFormat))
                .send(txConfig);
        });
    }
    setPubkey(ENSName, x, y, txConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolverContract = yield this.getResolverContractAdapter(ENSName);
            yield this.checkInterfaceSupport(resolverContract, config_1.methodsInInterface.setPubkey);
            return resolverContract.methods
                .setPubkey((0, utils_1.namehash)(ENSName), (0, utils_1.namehash)(x), (0, utils_1.namehash)(y))
                .send(txConfig);
        });
    }
    setContenthash(ENSName, hash, txConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolverContract = yield this.getResolverContractAdapter(ENSName);
            yield this.checkInterfaceSupport(resolverContract, config_1.methodsInInterface.setContenthash);
            return resolverContract.methods.setContenthash((0, utils_1.namehash)(ENSName), hash).send(txConfig);
        });
    }
    supportsInterface(ENSName, interfaceId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const resolverContract = yield this.getResolverContractAdapter(ENSName);
            let interfaceIdParam = interfaceId;
            if (!(0, web3_utils_1.isHexStrict)(interfaceIdParam)) {
                interfaceIdParam = (_a = (0, web3_utils_1.sha3)(interfaceId)) !== null && _a !== void 0 ? _a : '';
                if (interfaceId === '')
                    throw new Error('Invalid interface Id');
                interfaceIdParam = interfaceIdParam.slice(0, 10);
            }
            return resolverContract.methods.supportsInterface(interfaceIdParam).call();
        });
    }
    getAddress(ENSName, coinType = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolverContract = yield this.getResolverContractAdapter(ENSName);
            yield this.checkInterfaceSupport(resolverContract, config_1.methodsInInterface.addr);
            return resolverContract.methods.addr((0, utils_1.namehash)(ENSName), coinType).call();
        });
    }
    getPubkey(ENSName) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolverContract = yield this.getResolverContractAdapter(ENSName);
            yield this.checkInterfaceSupport(resolverContract, config_1.methodsInInterface.pubkey);
            return resolverContract.methods.pubkey((0, utils_1.namehash)(ENSName)).call();
        });
    }
    getContenthash(ENSName) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolverContract = yield this.getResolverContractAdapter(ENSName);
            yield this.checkInterfaceSupport(resolverContract, config_1.methodsInInterface.contenthash);
            return resolverContract.methods.contenthash((0, utils_1.namehash)(ENSName)).call();
        });
    }
}
exports.Resolver = Resolver;
//# sourceMappingURL=resolver.js.map