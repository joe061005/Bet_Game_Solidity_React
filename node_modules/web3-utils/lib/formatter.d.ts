/// <reference types="node" />
import { Bytes, HexString, Numbers } from 'web3-types';
import { JsonSchema, ValidationSchemaInput } from 'web3-validator';
export declare enum FMT_NUMBER {
    NUMBER = "NUMBER_NUMBER",
    HEX = "NUMBER_HEX",
    STR = "NUMBER_STR",
    BIGINT = "NUMBER_BIGINT"
}
export declare type NumberTypes = {
    [FMT_NUMBER.NUMBER]: number;
    [FMT_NUMBER.HEX]: HexString;
    [FMT_NUMBER.STR]: string;
    [FMT_NUMBER.BIGINT]: bigint;
};
export declare enum FMT_BYTES {
    HEX = "BYTES_HEX",
    BUFFER = "BYTES_BUFFER",
    UINT8ARRAY = "BYTES_UINT8ARRAY"
}
export declare type ByteTypes = {
    [FMT_BYTES.HEX]: HexString;
    [FMT_BYTES.BUFFER]: Buffer;
    [FMT_BYTES.UINT8ARRAY]: Uint8Array;
};
export declare type DataFormat = {
    readonly number: FMT_NUMBER;
    readonly bytes: FMT_BYTES;
};
export declare const DEFAULT_RETURN_FORMAT: {
    readonly number: FMT_NUMBER.BIGINT;
    readonly bytes: FMT_BYTES.HEX;
};
export declare const ETH_DATA_FORMAT: {
    readonly number: FMT_NUMBER.HEX;
    readonly bytes: FMT_BYTES.HEX;
};
export declare const isDataFormat: (dataFormat: unknown) => dataFormat is DataFormat;
export declare type FormatType<T, F extends DataFormat> = number extends Extract<T, Numbers> ? NumberTypes[F['number']] | Exclude<T, Numbers> : Buffer extends Extract<T, Bytes> ? ByteTypes[F['bytes']] | Exclude<T, Bytes> : T extends object | undefined ? {
    [P in keyof T]: FormatType<T[P], F>;
} : T;
export declare const convertScalarValue: (value: unknown, ethType: string, format: DataFormat) => unknown;
export declare const convert: (data: Record<string, unknown> | unknown[] | unknown, schema: JsonSchema, dataPath: string[], format: DataFormat, oneOfPath?: [string, number][]) => unknown;
export declare const format: <DataType extends unknown, ReturnType_1 extends DataFormat>(schema: ValidationSchemaInput | JsonSchema, data: DataType, returnFormat: ReturnType_1) => FormatType<DataType, ReturnType_1>;
//# sourceMappingURL=formatter.d.ts.map