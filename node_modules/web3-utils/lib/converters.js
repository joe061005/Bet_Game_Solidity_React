"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toChecksumAddress = exports.toWei = exports.fromWei = exports.toBigInt = exports.toNumber = exports.toHex = exports.toAscii = exports.hexToAscii = exports.fromAscii = exports.asciiToHex = exports.hexToString = exports.toUtf8 = exports.hexToUtf8 = exports.stringToHex = exports.fromUtf8 = exports.utf8ToHex = exports.hexToNumberString = exports.fromDecimal = exports.numberToHex = exports.toDecimal = exports.hexToNumber = exports.hexToBytes = exports.bytesToHex = exports.bytesToBuffer = exports.ethUnitMap = void 0;
const web3_validator_1 = require("web3-validator");
const keccak_1 = require("ethereum-cryptography/keccak");
const web3_errors_1 = require("web3-errors");
const base = BigInt(10);
const expo10 = (expo) => base ** BigInt(expo);
exports.ethUnitMap = {
    noether: BigInt('0'),
    wei: BigInt(1),
    kwei: expo10(3),
    Kwei: expo10(3),
    babbage: expo10(3),
    femtoether: expo10(3),
    mwei: expo10(6),
    Mwei: expo10(6),
    lovelace: expo10(6),
    picoether: expo10(6),
    gwei: expo10(9),
    Gwei: expo10(9),
    shannon: expo10(9),
    nanoether: expo10(9),
    nano: expo10(9),
    szabo: expo10(12),
    microether: expo10(12),
    micro: expo10(12),
    finney: expo10(15),
    milliether: expo10(15),
    milli: expo10(15),
    ether: expo10(18),
    kether: expo10(21),
    grand: expo10(21),
    mether: expo10(24),
    gether: expo10(27),
    tether: expo10(30),
};
const bytesToBuffer = (data) => {
    web3_validator_1.validator.validate(['bytes'], [data]);
    if (Buffer.isBuffer(data)) {
        return data;
    }
    if (data instanceof Uint8Array || Array.isArray(data)) {
        return Buffer.from(data);
    }
    if (typeof data === 'string' && (0, web3_validator_1.isHexStrict)(data)) {
        const dataWithoutPrefix = data.toLowerCase().replace('0x', '');
        const dataLength = dataWithoutPrefix.length + (dataWithoutPrefix.length % 2);
        const finalData = dataWithoutPrefix.padStart(dataLength, '0');
        return Buffer.from(finalData, 'hex');
    }
    if (typeof data === 'string' && !(0, web3_validator_1.isHexStrict)(data)) {
        return Buffer.from(data, 'hex');
    }
    throw new web3_errors_1.InvalidBytesError(data);
};
exports.bytesToBuffer = bytesToBuffer;
const bufferToHexString = (data) => `0x${data.toString('hex')}`;
const bytesToHex = (bytes) => bufferToHexString((0, exports.bytesToBuffer)(bytes));
exports.bytesToHex = bytesToHex;
const hexToBytes = (bytes) => (0, exports.bytesToBuffer)(bytes);
exports.hexToBytes = hexToBytes;
const hexToNumber = (value) => {
    web3_validator_1.validator.validate(['hex'], [value]);
    return web3_validator_1.utils.hexToNumber(value);
};
exports.hexToNumber = hexToNumber;
exports.toDecimal = exports.hexToNumber;
const numberToHex = (value) => {
    web3_validator_1.validator.validate(['int'], [value]);
    return web3_validator_1.utils.numberToHex(value);
};
exports.numberToHex = numberToHex;
exports.fromDecimal = exports.numberToHex;
const hexToNumberString = (data) => (0, exports.hexToNumber)(data).toString();
exports.hexToNumberString = hexToNumberString;
const utf8ToHex = (str) => {
    web3_validator_1.validator.validate(['string'], [str]);
    let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, '');
    strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, '');
    return `0x${Buffer.from(strWithoutNullCharacter, 'utf8').toString('hex')}`;
};
exports.utf8ToHex = utf8ToHex;
exports.fromUtf8 = exports.utf8ToHex;
exports.stringToHex = exports.utf8ToHex;
const hexToUtf8 = (str) => (0, exports.bytesToBuffer)(str).toString('utf8');
exports.hexToUtf8 = hexToUtf8;
exports.toUtf8 = exports.hexToUtf8;
exports.hexToString = exports.hexToUtf8;
const asciiToHex = (str) => {
    web3_validator_1.validator.validate(['string'], [str]);
    return `0x${Buffer.from(str, 'ascii').toString('hex')}`;
};
exports.asciiToHex = asciiToHex;
exports.fromAscii = exports.asciiToHex;
const hexToAscii = (str) => (0, exports.bytesToBuffer)(str).toString('ascii');
exports.hexToAscii = hexToAscii;
exports.toAscii = exports.hexToAscii;
const toHex = (value, returnType) => {
    if (typeof value === 'string' && (0, web3_validator_1.isAddress)(value)) {
        return returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`;
    }
    if (typeof value === 'boolean') {
        return returnType ? 'bool' : value ? '0x01' : '0x00';
    }
    if (typeof value === 'number') {
        return returnType ? (value < 0 ? 'int256' : 'uint256') : (0, exports.numberToHex)(value);
    }
    if (typeof value === 'bigint') {
        return returnType ? 'bigint' : (0, exports.numberToHex)(value);
    }
    if (typeof value === 'object' && !!value) {
        return returnType ? 'string' : (0, exports.utf8ToHex)(JSON.stringify(value));
    }
    if (typeof value === 'string') {
        if (value.startsWith('-0x') || value.startsWith('-0X')) {
            return returnType ? 'int256' : (0, exports.numberToHex)(value);
        }
        if ((0, web3_validator_1.isHexStrict)(value)) {
            return returnType ? 'bytes' : value;
        }
        if (!Number.isFinite(value)) {
            return returnType ? 'string' : (0, exports.utf8ToHex)(value);
        }
    }
    throw new web3_errors_1.HexProcessingError(value);
};
exports.toHex = toHex;
const toNumber = (value) => {
    if (typeof value === 'number') {
        return value;
    }
    if (typeof value === 'bigint') {
        return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER
            ? Number(value)
            : value;
    }
    if (typeof value === 'string' && (0, web3_validator_1.isHexStrict)(value)) {
        return (0, exports.hexToNumber)(value);
    }
    try {
        return (0, exports.toNumber)(BigInt(value));
    }
    catch (_a) {
        throw new web3_errors_1.InvalidNumberError(value);
    }
};
exports.toNumber = toNumber;
const toBigInt = (value) => {
    if (typeof value === 'number') {
        return BigInt(value);
    }
    if (typeof value === 'bigint') {
        return value;
    }
    if (typeof value === 'string' && (0, web3_validator_1.isHex)(value)) {
        return BigInt(value);
    }
    throw new web3_errors_1.InvalidNumberError(value);
};
exports.toBigInt = toBigInt;
const fromWei = (number, unit) => {
    const denomination = exports.ethUnitMap[unit];
    if (!denomination) {
        throw new web3_errors_1.InvalidUnitError(unit);
    }
    const value = String((0, exports.toNumber)(number));
    const numberOfZerosInDenomination = denomination.toString().length - 1;
    if (numberOfZerosInDenomination <= 0) {
        return value.toString();
    }
    const zeroPaddedValue = value.padStart(numberOfZerosInDenomination, '0');
    const integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination);
    const fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\.?0+$/, '');
    if (integer === '') {
        return `0.${fraction}`;
    }
    if (fraction === '') {
        return integer;
    }
    return `${integer}.${fraction}`;
};
exports.fromWei = fromWei;
const toWei = (number, unit) => {
    web3_validator_1.validator.validate(['number'], [number]);
    const denomination = exports.ethUnitMap[unit];
    if (!denomination) {
        throw new web3_errors_1.InvalidUnitError(unit);
    }
    const [integer, fraction] = String(typeof number === 'string' && !(0, web3_validator_1.isHexStrict)(number) ? number : (0, exports.toNumber)(number))
        .split('.')
        .concat('');
    const value = BigInt(`${integer}${fraction}`);
    const updatedValue = value * denomination;
    const numberOfZerosInDenomination = denomination.toString().length - 1;
    const decimals = Math.min(fraction.length, numberOfZerosInDenomination);
    if (decimals === 0) {
        return updatedValue.toString();
    }
    return updatedValue.toString().padStart(decimals, '0').slice(0, -decimals);
};
exports.toWei = toWei;
const toChecksumAddress = (address) => {
    if (!(0, web3_validator_1.isAddress)(address, false)) {
        throw new web3_errors_1.InvalidAddressError(address);
    }
    const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, '');
    const hash = (0, exports.bytesToHex)((0, keccak_1.keccak256)(Buffer.from(lowerCaseAddress)));
    if ((0, web3_validator_1.isNullish)(hash) ||
        hash === 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470')
        return '';
    const addressHash = hash.replace(/^0x/i, '');
    let checksumAddress = '0x';
    for (let i = 0; i < lowerCaseAddress.length; i += 1) {
        if (parseInt(addressHash[i], 16) > 7) {
            checksumAddress += lowerCaseAddress[i].toUpperCase();
        }
        else {
            checksumAddress += lowerCaseAddress[i];
        }
    }
    return checksumAddress;
};
exports.toChecksumAddress = toChecksumAddress;
//# sourceMappingURL=converters.js.map