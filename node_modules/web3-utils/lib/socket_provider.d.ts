import { ConnectionEvent, EthExecutionAPI, JsonRpcId, JsonRpcResponse, JsonRpcResponseWithResult, JsonRpcResult, SocketRequestItem, Web3APIMethod, Web3APIPayload, Web3APIReturnType, Web3APISpec, Web3ProviderEventCallback, Web3ProviderStatus } from 'web3-types';
import { Eip1193Provider } from './web3_eip1193_provider';
import { ChunkResponseParser } from './chunk_response_parser';
declare type ReconnectOptions = {
    autoReconnect: boolean;
    delay: number;
    maxAttempts: number;
};
declare type EventType = 'message' | 'connect' | 'disconnect' | 'chainChanged' | 'accountsChanged' | string;
export declare abstract class SocketProvider<MessageEvent, CloseEvent, ErrorEvent, API extends Web3APISpec = EthExecutionAPI> extends Eip1193Provider<API> {
    protected isReconnecting: boolean;
    protected readonly _socketPath: string;
    protected readonly chunkResponseParser: ChunkResponseParser;
    protected readonly _pendingRequestsQueue: Map<JsonRpcId, SocketRequestItem<any, any, any>>;
    protected readonly _sentRequestsQueue: Map<JsonRpcId, SocketRequestItem<any, any, any>>;
    protected _reconnectAttempts: number;
    protected readonly _socketOptions?: object;
    protected readonly _reconnectOptions: ReconnectOptions;
    protected _socketConnection?: unknown;
    get SocketConnection(): unknown;
    protected _connectionStatus: Web3ProviderStatus;
    protected readonly _onMessageHandler: (event: MessageEvent) => void;
    protected readonly _onOpenHandler: () => void;
    protected readonly _onCloseHandler: (event: CloseEvent) => void;
    protected readonly _onErrorHandler: (event: ErrorEvent) => void;
    constructor(socketPath: string, socketOptions?: object, reconnectOptions?: object);
    protected _init(): void;
    connect(): void;
    protected abstract _openSocketConnection(): void;
    protected abstract _addSocketListeners(): void;
    protected abstract _removeSocketListeners(): void;
    protected abstract _onCloseEvent(_event: unknown): void;
    protected abstract _sendToSocket(_payload: Web3APIPayload<API, any>): void;
    protected abstract _parseResponses(_event: MessageEvent): JsonRpcResponse[];
    protected abstract _closeSocketConnection(_code?: number, _data?: string): void;
    protected _validateProviderPath(path: string): boolean;
    supportsSubscriptions(): boolean;
    on<T = JsonRpcResult>(type: EventType, callback: Web3ProviderEventCallback<T>): void;
    once<T = JsonRpcResult>(type: EventType, callback: Web3ProviderEventCallback<T>): void;
    removeListener(type: EventType, callback: Web3ProviderEventCallback): void;
    protected _onDisconnect(code?: number, data?: string): void;
    disconnect(code?: number, data?: string): void;
    removeAllListeners(type: string): void;
    protected _onError(event: ErrorEvent): void;
    reset(): void;
    protected _reconnect(): void;
    request<Method extends Web3APIMethod<API>, ResultType = Web3APIReturnType<API, Method>>(request: Web3APIPayload<API, Method>): Promise<JsonRpcResponseWithResult<ResultType>>;
    protected _onConnect(): void;
    private _sendPendingRequests;
    protected _onMessage(event: MessageEvent): void;
    protected _clearQueues(event?: ConnectionEvent): void;
}
export {};
//# sourceMappingURL=socket_provider.d.ts.map