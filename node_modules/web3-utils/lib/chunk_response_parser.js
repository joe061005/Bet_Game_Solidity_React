"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChunkResponseParser = void 0;
const web3_errors_1 = require("web3-errors");
class ChunkResponseParser {
    clearQueues() {
        if (typeof this._clearQueues === 'function') {
            this._clearQueues();
        }
    }
    onError(clearQueues) {
        this._clearQueues = clearQueues;
    }
    parseResponse(data) {
        const returnValues = [];
        const dechunkedData = data
            .replace(/\}[\n\r]?\{/g, '}|--|{')
            .replace(/\}\][\n\r]?\[\{/g, '}]|--|[{')
            .replace(/\}[\n\r]?\[\{/g, '}|--|[{')
            .replace(/\}\][\n\r]?\{/g, '}]|--|{')
            .split('|--|');
        dechunkedData.forEach(_chunkData => {
            let chunkData = _chunkData;
            if (this.lastChunk) {
                chunkData = this.lastChunk + chunkData;
            }
            let result;
            try {
                result = JSON.parse(chunkData);
            }
            catch (e) {
                this.lastChunk = chunkData;
                if (this.lastChunkTimeout) {
                    clearTimeout(this.lastChunkTimeout);
                }
                this.lastChunkTimeout = setTimeout(() => {
                    this.clearQueues();
                    throw new web3_errors_1.InvalidResponseError({
                        id: 1,
                        jsonrpc: '2.0',
                        error: { code: 2, message: 'Chunk timeout' },
                    });
                }, 1000 * 15);
                return;
            }
            clearTimeout(this.lastChunkTimeout);
            this.lastChunk = undefined;
            if (result)
                returnValues.push(result);
        });
        return returnValues;
    }
}
exports.ChunkResponseParser = ChunkResponseParser;
//# sourceMappingURL=chunk_response_parser.js.map