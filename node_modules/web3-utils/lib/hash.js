"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStorageSlotNumForLongString = exports.soliditySha3Raw = exports.soliditySha3 = exports.encodePacked = exports.processSolidityEncodePackedArgs = exports.keccak256 = exports.keccak256Wrapper = exports.sha3Raw = exports.sha3 = void 0;
const web3_errors_1 = require("web3-errors");
const keccak_1 = require("ethereum-cryptography/keccak");
const web3_validator_1 = require("web3-validator");
const string_manipulation_1 = require("./string_manipulation");
const converters_1 = require("./converters");
const SHA3_EMPTY_BYTES = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
const sha3 = (data) => {
    const updatedData = typeof data === 'string' && (0, web3_validator_1.isHexStrict)(data) ? (0, converters_1.hexToBytes)(data) : data;
    const hash = (0, converters_1.bytesToHex)((0, keccak_1.keccak256)(Buffer.from(updatedData)));
    return hash === SHA3_EMPTY_BYTES ? undefined : hash;
};
exports.sha3 = sha3;
const sha3Raw = (data) => {
    const hash = (0, exports.sha3)(data);
    if ((0, web3_validator_1.isNullish)(hash)) {
        return SHA3_EMPTY_BYTES;
    }
    return hash;
};
exports.sha3Raw = sha3Raw;
const keccak256Wrapper = (data) => {
    let processedData;
    if (typeof data === 'bigint' || typeof data === 'number') {
        processedData = data.toString();
    }
    else if (typeof data === 'string' && (0, web3_validator_1.isHexStrict)(data)) {
        processedData = (0, converters_1.bytesToBuffer)(data);
    }
    else {
        processedData = data;
    }
    return (0, converters_1.bytesToHex)((0, keccak_1.keccak256)(Buffer.from(processedData)));
};
exports.keccak256Wrapper = keccak256Wrapper;
exports.keccak256 = exports.keccak256Wrapper;
const getType = (arg) => {
    if (Array.isArray(arg)) {
        throw new Error('Autodetection of array types is not supported.');
    }
    let type;
    let value;
    if (typeof arg === 'object' &&
        ('t' in arg || 'type' in arg) &&
        ('v' in arg || 'value' in arg)) {
        type = 't' in arg ? arg.t : arg.type;
        value = 'v' in arg ? arg.v : arg.value;
    }
    else {
        type = (0, converters_1.toHex)(arg, true);
        value = (0, converters_1.toHex)(arg);
        if (!type.startsWith('int') && !type.startsWith('uint')) {
            type = 'bytes';
        }
    }
    if ((type.startsWith('int') || type.startsWith('uint')) &&
        typeof value === 'string' &&
        !/^(-)?0x/i.test(value)) {
        value = (0, converters_1.toBigInt)(value);
    }
    return [type, value];
};
const elementaryName = (name) => {
    if (name.startsWith('int[')) {
        return `int256${name.slice(3)}`;
    }
    if (name === 'int') {
        return 'int256';
    }
    if (name.startsWith('uint[')) {
        return `uint256'${name.slice(4)}`;
    }
    if (name === 'uint') {
        return 'uint256';
    }
    return name;
};
const parseTypeN = (value, typeLength) => {
    const typesize = /^(\d+).*$/.exec(value.slice(typeLength));
    return typesize ? parseInt(typesize[1], 10) : 0;
};
const bitLength = (value) => {
    const updatedVal = value.toString(2);
    return updatedVal.length;
};
const solidityPack = (type, val) => {
    const value = val.toString();
    if (type === 'string') {
        if (typeof val === 'string')
            return (0, converters_1.utf8ToHex)(val);
        throw new web3_errors_1.InvalidStringError(val);
    }
    if (type === 'bool' || type === 'boolean') {
        if (typeof val === 'boolean')
            return val ? '01' : '00';
        throw new web3_errors_1.InvalidBooleanError(val);
    }
    if (type === 'address') {
        if (!(0, web3_validator_1.isAddress)(value)) {
            throw new web3_errors_1.InvalidAddressError(value);
        }
        return value;
    }
    const name = elementaryName(type);
    if (type.startsWith('uint')) {
        const size = parseTypeN(name, 'uint'.length);
        if (size % 8 || size < 8 || size > 256) {
            throw new web3_errors_1.InvalidSizeError(value);
        }
        const num = (0, converters_1.toNumber)(value);
        if (bitLength(num) > size) {
            throw new web3_errors_1.InvalidLargeValueError(value);
        }
        if (num < BigInt(0)) {
            throw new web3_errors_1.InvalidUnsignedIntegerError(value);
        }
        return size ? (0, string_manipulation_1.leftPad)(num.toString(16), (size / 8) * 2) : num.toString(16);
    }
    if (type.startsWith('int')) {
        const size = parseTypeN(name, 'int'.length);
        if (size % 8 || size < 8 || size > 256) {
            throw new web3_errors_1.InvalidSizeError(type);
        }
        const num = (0, converters_1.toNumber)(value);
        if (bitLength(num) > size) {
            throw new web3_errors_1.InvalidLargeValueError(value);
        }
        if (num < BigInt(0)) {
            return (0, string_manipulation_1.toTwosComplement)(num.toString(), (size / 8) * 2);
        }
        return size ? (0, string_manipulation_1.leftPad)(num.toString(16), size / 4) : num.toString(16);
    }
    if (name === 'bytes') {
        if (value.replace(/^0x/i, '').length % 2 !== 0) {
            throw new web3_errors_1.InvalidBytesError(value);
        }
        return value;
    }
    if (type.startsWith('bytes')) {
        if (value.replace(/^0x/i, '').length % 2 !== 0) {
            throw new web3_errors_1.InvalidBytesError(value);
        }
        const size = parseTypeN(type, 'bytes'.length);
        if (!size || size < 1 || size > 64 || size < value.replace(/^0x/i, '').length / 2) {
            throw new web3_errors_1.InvalidBytesError(value);
        }
        return (0, string_manipulation_1.rightPad)(value, size * 2);
    }
    return '';
};
const processSolidityEncodePackedArgs = (arg) => {
    const [type, val] = getType(arg);
    if (Array.isArray(val)) {
        const hexArg = val.map((v) => solidityPack(type, v).replace('0x', ''));
        return hexArg.join('');
    }
    const hexArg = solidityPack(type, val);
    return hexArg.replace('0x', '');
};
exports.processSolidityEncodePackedArgs = processSolidityEncodePackedArgs;
const encodePacked = (...values) => {
    const args = Array.prototype.slice.call(values);
    const hexArgs = args.map(exports.processSolidityEncodePackedArgs);
    return `0x${hexArgs.join('').toLowerCase()}`;
};
exports.encodePacked = encodePacked;
const soliditySha3 = (...values) => (0, exports.sha3)((0, exports.encodePacked)(...values));
exports.soliditySha3 = soliditySha3;
const soliditySha3Raw = (...values) => (0, exports.sha3Raw)((0, exports.encodePacked)(...values));
exports.soliditySha3Raw = soliditySha3Raw;
const getStorageSlotNumForLongString = (mainSlotNumber) => (0, exports.sha3)(`0x${(typeof mainSlotNumber === 'number'
    ? mainSlotNumber.toString()
    : mainSlotNumber).padStart(64, '0')}`);
exports.getStorageSlotNumForLongString = getStorageSlotNumForLongString;
//# sourceMappingURL=hash.js.map