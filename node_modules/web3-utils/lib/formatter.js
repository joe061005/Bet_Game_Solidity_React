"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.format = exports.convert = exports.convertScalarValue = exports.isDataFormat = exports.ETH_DATA_FORMAT = exports.DEFAULT_RETURN_FORMAT = exports.FMT_BYTES = exports.FMT_NUMBER = void 0;
const web3_errors_1 = require("web3-errors");
const web3_validator_1 = require("web3-validator");
const converters_1 = require("./converters");
const objects_1 = require("./objects");
const { parseBaseType } = web3_validator_1.utils;
var FMT_NUMBER;
(function (FMT_NUMBER) {
    FMT_NUMBER["NUMBER"] = "NUMBER_NUMBER";
    FMT_NUMBER["HEX"] = "NUMBER_HEX";
    FMT_NUMBER["STR"] = "NUMBER_STR";
    FMT_NUMBER["BIGINT"] = "NUMBER_BIGINT";
})(FMT_NUMBER = exports.FMT_NUMBER || (exports.FMT_NUMBER = {}));
var FMT_BYTES;
(function (FMT_BYTES) {
    FMT_BYTES["HEX"] = "BYTES_HEX";
    FMT_BYTES["BUFFER"] = "BYTES_BUFFER";
    FMT_BYTES["UINT8ARRAY"] = "BYTES_UINT8ARRAY";
})(FMT_BYTES = exports.FMT_BYTES || (exports.FMT_BYTES = {}));
exports.DEFAULT_RETURN_FORMAT = { number: FMT_NUMBER.BIGINT, bytes: FMT_BYTES.HEX };
exports.ETH_DATA_FORMAT = { number: FMT_NUMBER.HEX, bytes: FMT_BYTES.HEX };
const isDataFormat = (dataFormat) => typeof dataFormat === 'object' &&
    !(0, web3_validator_1.isNullish)(dataFormat) &&
    'number' in dataFormat &&
    'bytes' in dataFormat;
exports.isDataFormat = isDataFormat;
const findSchemaByDataPath = (schema, dataPath, oneOfPath = []) => {
    let result = Object.assign({}, schema);
    let previousDataPath;
    for (const dataPart of dataPath) {
        if (result.oneOf && previousDataPath) {
            const path = oneOfPath.find(function (element) {
                return this === element[0];
            }, previousDataPath !== null && previousDataPath !== void 0 ? previousDataPath : '');
            if (path && path[0] === previousDataPath) {
                result = result.oneOf[path[1]];
            }
        }
        if (!result.properties && !result.items) {
            return undefined;
        }
        if (result.properties) {
            result = result.properties[dataPart];
        }
        else if (result.items && result.items.properties) {
            const node = result.items.properties;
            if (!node) {
                return undefined;
            }
            result = node[dataPart];
        }
        else if (result.items && (0, web3_validator_1.isObject)(result.items)) {
            result = result.items;
        }
        else if (result.items && Array.isArray(result.items)) {
            result = result.items[parseInt(dataPart, 10)];
        }
        if (result && dataPart)
            previousDataPath = dataPart;
    }
    return result;
};
const convertScalarValue = (value, ethType, format) => {
    try {
        const { baseType } = parseBaseType(ethType);
        if (baseType === 'int' || baseType === 'uint') {
            switch (format.number) {
                case FMT_NUMBER.NUMBER:
                    return Number((0, converters_1.toBigInt)(value));
                case FMT_NUMBER.HEX:
                    return (0, converters_1.numberToHex)((0, converters_1.toBigInt)(value));
                case FMT_NUMBER.STR:
                    return (0, converters_1.toBigInt)(value).toString();
                case FMT_NUMBER.BIGINT:
                    return (0, converters_1.toBigInt)(value);
                default:
                    throw new web3_errors_1.FormatterError(`Invalid format: ${String(format.number)}`);
            }
        }
        if (baseType === 'bytes') {
            switch (format.bytes) {
                case FMT_BYTES.HEX:
                    return (0, converters_1.bytesToHex)((0, converters_1.bytesToBuffer)(value));
                case FMT_BYTES.BUFFER:
                    return (0, converters_1.bytesToBuffer)(value);
                case FMT_BYTES.UINT8ARRAY:
                    return new Uint8Array((0, converters_1.bytesToBuffer)(value));
                default:
                    throw new web3_errors_1.FormatterError(`Invalid format: ${String(format.bytes)}`);
            }
        }
    }
    catch (error) {
        return value;
    }
    return value;
};
exports.convertScalarValue = convertScalarValue;
const convert = (data, schema, dataPath, format, oneOfPath = []) => {
    var _a;
    if (!(0, web3_validator_1.isObject)(data) && !Array.isArray(data)) {
        return (0, exports.convertScalarValue)(data, schema === null || schema === void 0 ? void 0 : schema.eth, format);
    }
    const object = data;
    for (const [key, value] of Object.entries(object)) {
        dataPath.push(key);
        const schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);
        if ((0, web3_validator_1.isNullish)(schemaProp)) {
            delete object[key];
            dataPath.pop();
            continue;
        }
        if ((0, web3_validator_1.isObject)(value)) {
            (0, exports.convert)(value, schema, dataPath, format);
            dataPath.pop();
            continue;
        }
        if (Array.isArray(value)) {
            let _schemaProp = schemaProp;
            if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== undefined) {
                schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {
                    var _a, _b;
                    if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) &&
                        ((typeof value[0] === 'object' &&
                            ((_a = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a === void 0 ? void 0 : _a.type) === 'object') ||
                            (typeof value[0] === 'string' &&
                                ((_b = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b === void 0 ? void 0 : _b.type) !== 'object'))) {
                        _schemaProp = oneOfSchemaProp;
                        oneOfPath.push([key, index]);
                    }
                });
            }
            if ((0, web3_validator_1.isNullish)(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {
                delete object[key];
                dataPath.pop();
                continue;
            }
            if ((0, web3_validator_1.isObject)(_schemaProp.items) && !(0, web3_validator_1.isNullish)(_schemaProp.items.eth)) {
                for (let i = 0; i < value.length; i += 1) {
                    object[key][i] = (0, exports.convertScalarValue)(value[i], (_a = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a === void 0 ? void 0 : _a.eth, format);
                }
                dataPath.pop();
                continue;
            }
            if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) &&
                (_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items).type === 'object') {
                for (const arrObject of value) {
                    (0, exports.convert)(arrObject, schema, dataPath, format, oneOfPath);
                }
                dataPath.pop();
                continue;
            }
            if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {
                for (let i = 0; i < value.length; i += 1) {
                    object[key][i] = (0, exports.convertScalarValue)(value[i], _schemaProp.items[i].eth, format);
                }
                dataPath.pop();
                continue;
            }
        }
        object[key] = (0, exports.convertScalarValue)(value, schemaProp.eth, format);
        dataPath.pop();
    }
    return object;
};
exports.convert = convert;
const format = (schema, data, returnFormat) => {
    let dataToParse;
    if ((0, web3_validator_1.isObject)(data)) {
        dataToParse = (0, objects_1.mergeDeep)({}, data);
    }
    else if (Array.isArray(data)) {
        dataToParse = [...data];
    }
    else {
        dataToParse = data;
    }
    const jsonSchema = (0, web3_validator_1.isObject)(schema) ? schema : web3_validator_1.utils.ethAbiToJsonSchema(schema);
    if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.eth) {
        throw new web3_errors_1.FormatterError('Invalid json schema for formatting');
    }
    return (0, exports.convert)(dataToParse, jsonSchema, [], returnFormat);
};
exports.format = format;
//# sourceMappingURL=formatter.js.map