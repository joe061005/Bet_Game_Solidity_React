"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Iban = void 0;
const web3_utils_1 = require("web3-utils");
const web3_errors_1 = require("web3-errors");
class Iban {
    constructor(iban) {
        this.toAddress = () => {
            if (this.isDirect()) {
                const base36 = this._iban.slice(4);
                const parsedBigInt = Iban._parseInt(base36, 36);
                const paddedBigInt = (0, web3_utils_1.leftPad)(parsedBigInt, 40);
                return (0, web3_utils_1.toChecksumAddress)(paddedBigInt);
            }
            throw new Error('Iban is indirect and cannot be converted. Must be length of 34 or 35');
        };
        if (Iban.isIndirect(iban) || Iban.isDirect(iban)) {
            this._iban = iban;
        }
        else {
            throw new Error('Invalid IBAN was provided');
        }
    }
    static isDirect(iban) {
        return iban.length === 34 || iban.length === 35;
    }
    static isIndirect(iban) {
        return iban.length === 20;
    }
    isDirect() {
        return Iban.isDirect(this._iban);
    }
    static fromBban(bban) {
        const countryCode = 'XE';
        const remainder = this._mod9710(this._iso13616Prepare(`${countryCode}00${bban}`));
        const checkDigit = `0${(98 - remainder).toString()}`.slice(-2);
        return new Iban(`${countryCode}${checkDigit}${bban}`);
    }
    static fromAddress(address) {
        if (!(0, web3_utils_1.isAddress)(address)) {
            throw new web3_errors_1.InvalidAddressError(address);
        }
        const num = BigInt((0, web3_utils_1.hexToNumber)(address));
        const base36 = num.toString(36);
        const padded = (0, web3_utils_1.leftPad)(base36, 15);
        return Iban.fromBban(padded.toUpperCase());
    }
    static toIban(address) {
        return Iban.fromAddress(address).toString();
    }
    static createIndirect(options) {
        return Iban.fromBban(`ETH${options.institution}${options.identifier}`);
    }
    client() {
        return this.isIndirect() ? this._iban.slice(11) : '';
    }
    checksum() {
        return this._iban.slice(2, 4);
    }
    institution() {
        return this.isIndirect() ? this._iban.slice(7, 11) : '';
    }
    isValid() {
        return Iban._isValid(this._iban);
    }
    static isValid(iban) {
        return Iban._isValid(iban);
    }
    toString() {
        return this._iban;
    }
    isIndirect() {
        return Iban.isIndirect(this._iban);
    }
}
exports.Iban = Iban;
Iban._iso13616Prepare = (iban) => {
    const A = 'A'.charCodeAt(0);
    const Z = 'Z'.charCodeAt(0);
    const upperIban = iban.toUpperCase();
    const modifiedIban = `${upperIban.slice(4)}${upperIban.slice(0, 4)}`;
    return modifiedIban
        .split('')
        .map(n => {
        const code = n.charCodeAt(0);
        if (code >= A && code <= Z) {
            return code - A + 10;
        }
        return n;
    })
        .join('');
};
Iban._parseInt = (str, base) => [...str].reduce((acc, curr) => BigInt(parseInt(curr, base)) + BigInt(base) * acc, BigInt(0));
Iban._mod9710 = (iban) => {
    let remainder = iban;
    let block;
    while (remainder.length > 2) {
        block = remainder.slice(0, 9);
        remainder = `${(parseInt(block, 10) % 97).toString()}${remainder.slice(block.length)}`;
    }
    return parseInt(remainder, 10) % 97;
};
Iban._isValid = (iban) => /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(iban) &&
    Iban._mod9710(Iban._iso13616Prepare(iban)) === 1;
Iban.toAddress = (iban) => {
    const ibanObject = new Iban(iban);
    return ibanObject.toAddress();
};
//# sourceMappingURL=iban.js.map