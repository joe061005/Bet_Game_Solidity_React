"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAccessList = exports.getFeeHistory = exports.getProof = exports.getChainId = exports.getLogs = exports.estimateGas = exports.call = exports.signTransaction = exports.sign = exports.sendSignedTransaction = exports.sendTransaction = exports.getTransactionCount = exports.getTransactionReceipt = exports.getTransactionFromBlock = exports.getPendingTransactions = exports.getTransaction = exports.getUncle = exports.getBlockUncleCount = exports.getBlockTransactionCount = exports.getBlock = exports.getCode = exports.getStorageAt = exports.getBalance = exports.getBlockNumber = exports.getGasPrice = exports.getHashRate = exports.isMining = exports.getCoinbase = exports.isSyncing = exports.getProtocolVersion = void 0;
const web3_core_1 = require("web3-core");
const web3_utils_1 = require("web3-utils");
const web3_validator_1 = require("web3-validator");
const web3_errors_1 = require("web3-errors");
const web3_rpc_methods_1 = require("web3-rpc-methods");
const tx_1 = require("@ethereumjs/tx");
const decode_signed_transaction_1 = require("./utils/decode_signed_transaction");
const schemas_1 = require("./schemas");
const transaction_builder_1 = require("./utils/transaction_builder");
const format_transaction_1 = require("./utils/format_transaction");
const get_transaction_gas_pricing_1 = require("./utils/get_transaction_gas_pricing");
const try_send_transaction_1 = require("./utils/try_send_transaction");
const wait_for_transaction_receipt_1 = require("./utils/wait_for_transaction_receipt");
const watch_transaction_for_confirmations_1 = require("./utils/watch_transaction_for_confirmations");
const constants_1 = require("./constants");
const get_transaction_error_1 = require("./utils/get_transaction_error");
const get_revert_reason_1 = require("./utils/get_revert_reason");
const getProtocolVersion = (web3Context) => __awaiter(void 0, void 0, void 0, function* () { return web3_rpc_methods_1.ethRpcMethods.getProtocolVersion(web3Context.requestManager); });
exports.getProtocolVersion = getProtocolVersion;
const isSyncing = (web3Context) => __awaiter(void 0, void 0, void 0, function* () { return web3_rpc_methods_1.ethRpcMethods.getSyncing(web3Context.requestManager); });
exports.isSyncing = isSyncing;
const getCoinbase = (web3Context) => __awaiter(void 0, void 0, void 0, function* () { return web3_rpc_methods_1.ethRpcMethods.getCoinbase(web3Context.requestManager); });
exports.getCoinbase = getCoinbase;
const isMining = (web3Context) => __awaiter(void 0, void 0, void 0, function* () { return web3_rpc_methods_1.ethRpcMethods.getMining(web3Context.requestManager); });
exports.isMining = isMining;
function getHashRate(web3Context, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield web3_rpc_methods_1.ethRpcMethods.getHashRate(web3Context.requestManager);
        return (0, web3_utils_1.format)({ eth: 'uint' }, response, returnFormat);
    });
}
exports.getHashRate = getHashRate;
function getGasPrice(web3Context, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield web3_rpc_methods_1.ethRpcMethods.getGasPrice(web3Context.requestManager);
        return (0, web3_utils_1.format)({ eth: 'uint' }, response, returnFormat);
    });
}
exports.getGasPrice = getGasPrice;
function getBlockNumber(web3Context, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield web3_rpc_methods_1.ethRpcMethods.getBlockNumber(web3Context.requestManager);
        return (0, web3_utils_1.format)({ eth: 'uint' }, response, returnFormat);
    });
}
exports.getBlockNumber = getBlockNumber;
function getBalance(web3Context, address, blockNumber = web3Context.defaultBlock, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
            ? blockNumber
            : (0, web3_utils_1.format)({ eth: 'uint' }, blockNumber, web3_utils_1.ETH_DATA_FORMAT);
        const response = yield web3_rpc_methods_1.ethRpcMethods.getBalance(web3Context.requestManager, address, blockNumberFormatted);
        return (0, web3_utils_1.format)({ eth: 'uint' }, response, returnFormat);
    });
}
exports.getBalance = getBalance;
function getStorageAt(web3Context, address, storageSlot, blockNumber = web3Context.defaultBlock, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const storageSlotFormatted = (0, web3_utils_1.format)({ eth: 'uint' }, storageSlot, web3_utils_1.ETH_DATA_FORMAT);
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
            ? blockNumber
            : (0, web3_utils_1.format)({ eth: 'uint' }, blockNumber, web3_utils_1.ETH_DATA_FORMAT);
        const response = yield web3_rpc_methods_1.ethRpcMethods.getStorageAt(web3Context.requestManager, address, storageSlotFormatted, blockNumberFormatted);
        return (0, web3_utils_1.format)({ eth: 'bytes' }, response, returnFormat);
    });
}
exports.getStorageAt = getStorageAt;
function getCode(web3Context, address, blockNumber = web3Context.defaultBlock, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
            ? blockNumber
            : (0, web3_utils_1.format)({ eth: 'uint' }, blockNumber, web3_utils_1.ETH_DATA_FORMAT);
        const response = yield web3_rpc_methods_1.ethRpcMethods.getCode(web3Context.requestManager, address, blockNumberFormatted);
        return (0, web3_utils_1.format)({ eth: 'bytes' }, response, returnFormat);
    });
}
exports.getCode = getCode;
function getBlock(web3Context, block = web3Context.defaultBlock, hydrated = false, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        let response;
        if ((0, web3_validator_1.isBytes)(block)) {
            const blockHashFormatted = (0, web3_utils_1.format)({ eth: 'bytes32' }, block, web3_utils_1.ETH_DATA_FORMAT);
            response = yield web3_rpc_methods_1.ethRpcMethods.getBlockByHash(web3Context.requestManager, blockHashFormatted, hydrated);
        }
        else {
            const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(block)
                ? block
                : (0, web3_utils_1.format)({ eth: 'uint' }, block, web3_utils_1.ETH_DATA_FORMAT);
            response = yield web3_rpc_methods_1.ethRpcMethods.getBlockByNumber(web3Context.requestManager, blockNumberFormatted, hydrated);
        }
        return (0, web3_utils_1.format)(schemas_1.blockSchema, response, returnFormat);
    });
}
exports.getBlock = getBlock;
function getBlockTransactionCount(web3Context, block = web3Context.defaultBlock, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        let response;
        if ((0, web3_validator_1.isBytes)(block)) {
            const blockHashFormatted = (0, web3_utils_1.format)({ eth: 'bytes32' }, block, web3_utils_1.ETH_DATA_FORMAT);
            response = yield web3_rpc_methods_1.ethRpcMethods.getBlockTransactionCountByHash(web3Context.requestManager, blockHashFormatted);
        }
        else {
            const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(block)
                ? block
                : (0, web3_utils_1.format)({ eth: 'uint' }, block, web3_utils_1.ETH_DATA_FORMAT);
            response = yield web3_rpc_methods_1.ethRpcMethods.getBlockTransactionCountByNumber(web3Context.requestManager, blockNumberFormatted);
        }
        return (0, web3_utils_1.format)({ eth: 'uint' }, response, returnFormat);
    });
}
exports.getBlockTransactionCount = getBlockTransactionCount;
function getBlockUncleCount(web3Context, block = web3Context.defaultBlock, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        let response;
        if ((0, web3_validator_1.isBytes)(block)) {
            const blockHashFormatted = (0, web3_utils_1.format)({ eth: 'bytes32' }, block, web3_utils_1.ETH_DATA_FORMAT);
            response = yield web3_rpc_methods_1.ethRpcMethods.getUncleCountByBlockHash(web3Context.requestManager, blockHashFormatted);
        }
        else {
            const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(block)
                ? block
                : (0, web3_utils_1.format)({ eth: 'uint' }, block, web3_utils_1.ETH_DATA_FORMAT);
            response = yield web3_rpc_methods_1.ethRpcMethods.getUncleCountByBlockNumber(web3Context.requestManager, blockNumberFormatted);
        }
        return (0, web3_utils_1.format)({ eth: 'uint' }, response, returnFormat);
    });
}
exports.getBlockUncleCount = getBlockUncleCount;
function getUncle(web3Context, block = web3Context.defaultBlock, uncleIndex, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const uncleIndexFormatted = (0, web3_utils_1.format)({ eth: 'uint' }, uncleIndex, web3_utils_1.ETH_DATA_FORMAT);
        let response;
        if ((0, web3_validator_1.isBytes)(block)) {
            const blockHashFormatted = (0, web3_utils_1.format)({ eth: 'bytes32' }, block, web3_utils_1.ETH_DATA_FORMAT);
            response = yield web3_rpc_methods_1.ethRpcMethods.getUncleByBlockHashAndIndex(web3Context.requestManager, blockHashFormatted, uncleIndexFormatted);
        }
        else {
            const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(block)
                ? block
                : (0, web3_utils_1.format)({ eth: 'uint' }, block, web3_utils_1.ETH_DATA_FORMAT);
            response = yield web3_rpc_methods_1.ethRpcMethods.getUncleByBlockNumberAndIndex(web3Context.requestManager, blockNumberFormatted, uncleIndexFormatted);
        }
        return (0, web3_utils_1.format)(schemas_1.blockSchema, response, returnFormat);
    });
}
exports.getUncle = getUncle;
function getTransaction(web3Context, transactionHash, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const transactionHashFormatted = (0, web3_utils_1.format)({ eth: 'bytes32' }, transactionHash, web3_utils_1.DEFAULT_RETURN_FORMAT);
        const response = yield web3_rpc_methods_1.ethRpcMethods.getTransactionByHash(web3Context.requestManager, transactionHashFormatted);
        return (0, web3_validator_1.isNullish)(response)
            ? response
            : (0, web3_utils_1.format)(schemas_1.transactionInfoSchema, response, returnFormat);
    });
}
exports.getTransaction = getTransaction;
function getPendingTransactions(web3Context, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield web3_rpc_methods_1.ethRpcMethods.getPendingTransactions(web3Context.requestManager);
        return response.map(transaction => (0, format_transaction_1.formatTransaction)(transaction, returnFormat));
    });
}
exports.getPendingTransactions = getPendingTransactions;
function getTransactionFromBlock(web3Context, block = web3Context.defaultBlock, transactionIndex, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const transactionIndexFormatted = (0, web3_utils_1.format)({ eth: 'uint' }, transactionIndex, web3_utils_1.ETH_DATA_FORMAT);
        let response;
        if ((0, web3_validator_1.isBytes)(block)) {
            const blockHashFormatted = (0, web3_utils_1.format)({ eth: 'bytes32' }, block, web3_utils_1.ETH_DATA_FORMAT);
            response = yield web3_rpc_methods_1.ethRpcMethods.getTransactionByBlockHashAndIndex(web3Context.requestManager, blockHashFormatted, transactionIndexFormatted);
        }
        else {
            const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(block)
                ? block
                : (0, web3_utils_1.format)({ eth: 'uint' }, block, web3_utils_1.ETH_DATA_FORMAT);
            response = yield web3_rpc_methods_1.ethRpcMethods.getTransactionByBlockNumberAndIndex(web3Context.requestManager, blockNumberFormatted, transactionIndexFormatted);
        }
        return (0, web3_validator_1.isNullish)(response)
            ? response
            : (0, web3_utils_1.format)(schemas_1.transactionInfoSchema, response, returnFormat);
    });
}
exports.getTransactionFromBlock = getTransactionFromBlock;
function getTransactionReceipt(web3Context, transactionHash, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const transactionHashFormatted = (0, web3_utils_1.format)({ eth: 'bytes32' }, transactionHash, web3_utils_1.DEFAULT_RETURN_FORMAT);
        const response = yield web3_rpc_methods_1.ethRpcMethods.getTransactionReceipt(web3Context.requestManager, transactionHashFormatted);
        return (0, web3_validator_1.isNullish)(response)
            ? response
            : (0, web3_utils_1.format)(schemas_1.transactionReceiptSchema, response, returnFormat);
    });
}
exports.getTransactionReceipt = getTransactionReceipt;
function getTransactionCount(web3Context, address, blockNumber = web3Context.defaultBlock, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
            ? blockNumber
            : (0, web3_utils_1.format)({ eth: 'uint' }, blockNumber, web3_utils_1.ETH_DATA_FORMAT);
        const response = yield web3_rpc_methods_1.ethRpcMethods.getTransactionCount(web3Context.requestManager, address, blockNumberFormatted);
        return (0, web3_utils_1.format)({ eth: 'uint' }, response, returnFormat);
    });
}
exports.getTransactionCount = getTransactionCount;
function sendTransaction(web3Context, transaction, returnFormat, options = { checkRevertBeforeSending: true }) {
    const promiEvent = new web3_core_1.Web3PromiEvent((resolve, reject) => {
        setImmediate(() => {
            (() => __awaiter(this, void 0, void 0, function* () {
                let transactionFormatted = (0, format_transaction_1.formatTransaction)(Object.assign(Object.assign({}, transaction), { from: (0, transaction_builder_1.getTransactionFromOrToAttr)('from', web3Context, transaction), to: (0, transaction_builder_1.getTransactionFromOrToAttr)('to', web3Context, transaction) }), web3_utils_1.ETH_DATA_FORMAT);
                if (!(options === null || options === void 0 ? void 0 : options.ignoreGasPricing) &&
                    (0, web3_validator_1.isNullish)(transactionFormatted.gasPrice) &&
                    ((0, web3_validator_1.isNullish)(transaction.maxPriorityFeePerGas) ||
                        (0, web3_validator_1.isNullish)(transaction.maxFeePerGas))) {
                    transactionFormatted = Object.assign(Object.assign({}, transactionFormatted), (yield (0, get_transaction_gas_pricing_1.getTransactionGasPricing)(transactionFormatted, web3Context, web3_utils_1.ETH_DATA_FORMAT)));
                }
                try {
                    if (options.checkRevertBeforeSending !== false) {
                        const reason = yield (0, get_revert_reason_1.getRevertReason)(web3Context, transactionFormatted, options.contractAbi);
                        if (reason !== undefined) {
                            const error = yield (0, get_transaction_error_1.getTransactionError)(web3Context, transactionFormatted, undefined, undefined, options.contractAbi, reason);
                            if (promiEvent.listenerCount('error') > 0) {
                                promiEvent.emit('error', error);
                            }
                            reject(error);
                            return;
                        }
                    }
                    if (promiEvent.listenerCount('sending') > 0) {
                        promiEvent.emit('sending', transactionFormatted);
                    }
                    let transactionHash;
                    let wallet;
                    if (web3Context.wallet && !(0, web3_validator_1.isNullish)(transactionFormatted.from)) {
                        wallet = web3Context.wallet.get(transactionFormatted.from);
                    }
                    if (wallet) {
                        const signedTransaction = yield wallet.signTransaction(transactionFormatted);
                        transactionHash = yield (0, try_send_transaction_1.trySendTransaction)(web3Context, () => __awaiter(this, void 0, void 0, function* () {
                            return web3_rpc_methods_1.ethRpcMethods.sendRawTransaction(web3Context.requestManager, signedTransaction.rawTransaction);
                        }), signedTransaction.transactionHash);
                    }
                    else {
                        transactionHash = yield (0, try_send_transaction_1.trySendTransaction)(web3Context, () => __awaiter(this, void 0, void 0, function* () {
                            return web3_rpc_methods_1.ethRpcMethods.sendTransaction(web3Context.requestManager, transactionFormatted);
                        }));
                    }
                    const transactionHashFormatted = (0, web3_utils_1.format)({ eth: 'bytes32' }, transactionHash, returnFormat);
                    if (promiEvent.listenerCount('sent') > 0) {
                        promiEvent.emit('sent', transactionFormatted);
                    }
                    if (promiEvent.listenerCount('transactionHash') > 0) {
                        promiEvent.emit('transactionHash', transactionHashFormatted);
                    }
                    const transactionReceipt = yield (0, wait_for_transaction_receipt_1.waitForTransactionReceipt)(web3Context, transactionHash, returnFormat);
                    const transactionReceiptFormatted = (0, web3_utils_1.format)(schemas_1.transactionReceiptSchema, transactionReceipt, returnFormat);
                    if (promiEvent.listenerCount('receipt') > 0) {
                        promiEvent.emit('receipt', transactionReceiptFormatted);
                    }
                    if (options === null || options === void 0 ? void 0 : options.transactionResolver) {
                        resolve(options === null || options === void 0 ? void 0 : options.transactionResolver(transactionReceiptFormatted));
                    }
                    else if (transactionReceipt.status === BigInt(0)) {
                        const error = yield (0, get_transaction_error_1.getTransactionError)(web3Context, transactionFormatted, transactionReceiptFormatted, undefined, options === null || options === void 0 ? void 0 : options.contractAbi);
                        if (promiEvent.listenerCount('error') > 0) {
                            promiEvent.emit('error', error);
                        }
                        reject(error);
                    }
                    else {
                        resolve(transactionReceiptFormatted);
                    }
                    if (promiEvent.listenerCount('confirmation') > 0) {
                        (0, watch_transaction_for_confirmations_1.watchTransactionForConfirmations)(web3Context, promiEvent, transactionReceiptFormatted, transactionHash, returnFormat);
                    }
                }
                catch (error) {
                    let _error = error;
                    if (_error instanceof web3_errors_1.ContractExecutionError && web3Context.handleRevert) {
                        _error = yield (0, get_transaction_error_1.getTransactionError)(web3Context, transactionFormatted, undefined, undefined, options === null || options === void 0 ? void 0 : options.contractAbi);
                    }
                    if ((_error instanceof web3_errors_1.InvalidResponseError ||
                        _error instanceof web3_errors_1.ContractExecutionError ||
                        _error instanceof web3_errors_1.TransactionRevertWithCustomError ||
                        _error instanceof web3_errors_1.TransactionRevertedWithoutReasonError ||
                        _error instanceof web3_errors_1.TransactionRevertInstructionError) &&
                        promiEvent.listenerCount('error') > 0) {
                        promiEvent.emit('error', _error);
                    }
                    reject(_error);
                }
            }))();
        });
    });
    return promiEvent;
}
exports.sendTransaction = sendTransaction;
function sendSignedTransaction(web3Context, signedTransaction, returnFormat, options = { checkRevertBeforeSending: true }) {
    const promiEvent = new web3_core_1.Web3PromiEvent((resolve, reject) => {
        setImmediate(() => {
            (() => __awaiter(this, void 0, void 0, function* () {
                const signedTransactionFormattedHex = (0, web3_utils_1.format)({ eth: 'bytes' }, signedTransaction, web3_utils_1.ETH_DATA_FORMAT);
                const unSerializedTransaction = tx_1.TransactionFactory.fromSerializedData((0, web3_utils_1.bytesToBuffer)((0, web3_utils_1.hexToBytes)(signedTransactionFormattedHex)));
                const unSerializedTransactionWithFrom = Object.assign(Object.assign({}, unSerializedTransaction.toJSON()), { from: unSerializedTransaction.getSenderAddress().toString() });
                try {
                    if (options.checkRevertBeforeSending !== false) {
                        const reason = yield (0, get_revert_reason_1.getRevertReason)(web3Context, unSerializedTransactionWithFrom, options.contractAbi);
                        if (reason !== undefined) {
                            const error = yield (0, get_transaction_error_1.getTransactionError)(web3Context, unSerializedTransactionWithFrom, undefined, undefined, options.contractAbi, reason);
                            if (promiEvent.listenerCount('error') > 0) {
                                promiEvent.emit('error', error);
                            }
                            reject(error);
                            return;
                        }
                    }
                    if (promiEvent.listenerCount('sending') > 0) {
                        promiEvent.emit('sending', signedTransactionFormattedHex);
                    }
                    const transactionHash = yield (0, try_send_transaction_1.trySendTransaction)(web3Context, () => __awaiter(this, void 0, void 0, function* () {
                        return web3_rpc_methods_1.ethRpcMethods.sendRawTransaction(web3Context.requestManager, signedTransactionFormattedHex);
                    }));
                    if (promiEvent.listenerCount('sent') > 0) {
                        promiEvent.emit('sent', signedTransactionFormattedHex);
                    }
                    const transactionHashFormatted = (0, web3_utils_1.format)({ eth: 'bytes32' }, transactionHash, returnFormat);
                    if (promiEvent.listenerCount('transactionHash') > 0) {
                        promiEvent.emit('transactionHash', transactionHashFormatted);
                    }
                    const transactionReceipt = yield (0, wait_for_transaction_receipt_1.waitForTransactionReceipt)(web3Context, transactionHash, returnFormat);
                    const transactionReceiptFormatted = (0, web3_utils_1.format)(schemas_1.transactionReceiptSchema, transactionReceipt, returnFormat);
                    if (promiEvent.listenerCount('receipt') > 0) {
                        promiEvent.emit('receipt', transactionReceiptFormatted);
                    }
                    if (options === null || options === void 0 ? void 0 : options.transactionResolver) {
                        resolve(options === null || options === void 0 ? void 0 : options.transactionResolver(transactionReceiptFormatted));
                    }
                    else if (transactionReceipt.status === BigInt(0)) {
                        const error = yield (0, get_transaction_error_1.getTransactionError)(web3Context, unSerializedTransactionWithFrom, transactionReceiptFormatted, undefined, options === null || options === void 0 ? void 0 : options.contractAbi);
                        if (promiEvent.listenerCount('error') > 0) {
                            promiEvent.emit('error', error);
                        }
                        reject(error);
                    }
                    else {
                        resolve(transactionReceiptFormatted);
                    }
                    if (promiEvent.listenerCount('confirmation') > 0) {
                        (0, watch_transaction_for_confirmations_1.watchTransactionForConfirmations)(web3Context, promiEvent, transactionReceiptFormatted, transactionHash, returnFormat);
                    }
                }
                catch (error) {
                    let _error = error;
                    if (_error instanceof web3_errors_1.ContractExecutionError && web3Context.handleRevert) {
                        _error = yield (0, get_transaction_error_1.getTransactionError)(web3Context, unSerializedTransactionWithFrom, undefined, undefined, options === null || options === void 0 ? void 0 : options.contractAbi);
                    }
                    if ((_error instanceof web3_errors_1.InvalidResponseError ||
                        _error instanceof web3_errors_1.ContractExecutionError ||
                        _error instanceof web3_errors_1.TransactionRevertWithCustomError ||
                        _error instanceof web3_errors_1.TransactionRevertedWithoutReasonError ||
                        _error instanceof web3_errors_1.TransactionRevertInstructionError) &&
                        promiEvent.listenerCount('error') > 0) {
                        promiEvent.emit('error', _error);
                    }
                    reject(_error);
                }
            }))();
        });
    });
    return promiEvent;
}
exports.sendSignedTransaction = sendSignedTransaction;
function sign(web3Context, message, addressOrIndex, returnFormat) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const messageFormatted = (0, web3_utils_1.format)({ eth: 'bytes' }, message, web3_utils_1.DEFAULT_RETURN_FORMAT);
        if ((_a = web3Context.wallet) === null || _a === void 0 ? void 0 : _a.get(addressOrIndex)) {
            const wallet = web3Context.wallet.get(addressOrIndex);
            return wallet.sign(messageFormatted);
        }
        if (typeof addressOrIndex === 'number') {
            throw new web3_errors_1.SignatureError(message, 'RPC method "eth_sign" does not support index signatures');
        }
        const response = yield web3_rpc_methods_1.ethRpcMethods.sign(web3Context.requestManager, addressOrIndex, messageFormatted);
        return (0, web3_utils_1.format)({ eth: 'bytes' }, response, returnFormat);
    });
}
exports.sign = sign;
function signTransaction(web3Context, transaction, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield web3_rpc_methods_1.ethRpcMethods.signTransaction(web3Context.requestManager, (0, format_transaction_1.formatTransaction)(transaction, web3_utils_1.ETH_DATA_FORMAT));
        return (0, web3_validator_1.isString)(response)
            ? (0, decode_signed_transaction_1.decodeSignedTransaction)(response, returnFormat)
            : {
                raw: (0, web3_utils_1.format)({ eth: 'bytes' }, response.raw, returnFormat),
                tx: (0, format_transaction_1.formatTransaction)(response.tx, returnFormat),
            };
    });
}
exports.signTransaction = signTransaction;
function call(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
            ? blockNumber
            : (0, web3_utils_1.format)({ eth: 'uint' }, blockNumber, web3_utils_1.ETH_DATA_FORMAT);
        const response = yield web3_rpc_methods_1.ethRpcMethods.call(web3Context.requestManager, (0, format_transaction_1.formatTransaction)(transaction, web3_utils_1.ETH_DATA_FORMAT), blockNumberFormatted);
        return (0, web3_utils_1.format)({ eth: 'bytes' }, response, returnFormat);
    });
}
exports.call = call;
function estimateGas(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const transactionFormatted = (0, format_transaction_1.formatTransaction)(transaction, web3_utils_1.ETH_DATA_FORMAT);
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
            ? blockNumber
            : (0, web3_utils_1.format)({ eth: 'uint' }, blockNumber, web3_utils_1.ETH_DATA_FORMAT);
        const response = yield web3_rpc_methods_1.ethRpcMethods.estimateGas(web3Context.requestManager, transactionFormatted, blockNumberFormatted);
        return (0, web3_utils_1.format)({ eth: 'uint' }, response, returnFormat);
    });
}
exports.estimateGas = estimateGas;
function getLogs(web3Context, filter, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield web3_rpc_methods_1.ethRpcMethods.getLogs(web3Context.requestManager, filter);
        const result = response.map(res => {
            if (typeof res === 'string') {
                return res;
            }
            return (0, web3_utils_1.format)(schemas_1.logSchema, res, returnFormat);
        });
        return result;
    });
}
exports.getLogs = getLogs;
function getChainId(web3Context, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield web3_rpc_methods_1.ethRpcMethods.getChainId(web3Context.requestManager);
        return (0, web3_utils_1.format)({ eth: 'uint' }, response, returnFormat);
    });
}
exports.getChainId = getChainId;
function getProof(web3Context, address, storageKeys, blockNumber = web3Context.defaultBlock, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const storageKeysFormatted = storageKeys.map(storageKey => (0, web3_utils_1.format)({ eth: 'bytes' }, storageKey, web3_utils_1.ETH_DATA_FORMAT));
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
            ? blockNumber
            : (0, web3_utils_1.format)({ eth: 'uint' }, blockNumber, web3_utils_1.ETH_DATA_FORMAT);
        const response = yield web3_rpc_methods_1.ethRpcMethods.getProof(web3Context.requestManager, address, storageKeysFormatted, blockNumberFormatted);
        return (0, web3_utils_1.format)(schemas_1.accountSchema, response, returnFormat);
    });
}
exports.getProof = getProof;
function getFeeHistory(web3Context, blockCount, newestBlock = web3Context.defaultBlock, rewardPercentiles, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const blockCountFormatted = (0, web3_utils_1.format)({ eth: 'uint' }, blockCount, web3_utils_1.ETH_DATA_FORMAT);
        const newestBlockFormatted = (0, web3_validator_1.isBlockTag)(newestBlock)
            ? newestBlock
            : (0, web3_utils_1.format)({ eth: 'uint' }, newestBlock, web3_utils_1.ETH_DATA_FORMAT);
        const rewardPercentilesFormatted = (0, web3_utils_1.format)({
            type: 'array',
            items: {
                eth: 'uint',
            },
        }, rewardPercentiles, constants_1.NUMBER_DATA_FORMAT);
        const response = yield web3_rpc_methods_1.ethRpcMethods.getFeeHistory(web3Context.requestManager, blockCountFormatted, newestBlockFormatted, rewardPercentilesFormatted);
        return (0, web3_utils_1.format)(schemas_1.feeHistorySchema, response, returnFormat);
    });
}
exports.getFeeHistory = getFeeHistory;
function createAccessList(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
    return __awaiter(this, void 0, void 0, function* () {
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
            ? blockNumber
            : (0, web3_utils_1.format)({ eth: 'uint' }, blockNumber, web3_utils_1.ETH_DATA_FORMAT);
        const response = (yield web3_rpc_methods_1.ethRpcMethods.createAccessList(web3Context.requestManager, (0, format_transaction_1.formatTransaction)(transaction, web3_utils_1.ETH_DATA_FORMAT), blockNumberFormatted));
        return (0, web3_utils_1.format)(schemas_1.accessListResultSchema, response, returnFormat);
    });
}
exports.createAccessList = createAccessList;
//# sourceMappingURL=rpc_method_wrappers.js.map