"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.padLeft = exports.numberToHex = exports.hexToNumber = exports.codePointToInt = exports.transformJsonDataToAbiFormat = exports.fetchArrayElement = exports.ethAbiToJsonSchema = exports.abiSchemaToJsonSchema = exports.parseBaseType = void 0;
const web3_errors_1 = require("web3-errors");
const constants_1 = require("./constants");
const abi_1 = require("./validation/abi");
const string_1 = require("./validation/string");
const parseBaseType = (type) => {
    let strippedType = type.replace(/ /, '');
    let baseTypeSize;
    let isArray = false;
    let arraySizes = [];
    if (type.includes('[')) {
        strippedType = strippedType.slice(0, strippedType.indexOf('['));
        arraySizes = [...type.matchAll(/(?:\[(\d*)\])/g)]
            .map(match => parseInt(match[1], 10))
            .map(size => (Number.isNaN(size) ? -1 : size));
        isArray = arraySizes.length > 0;
    }
    if (constants_1.VALID_ETH_BASE_TYPES.includes(strippedType)) {
        return { baseType: strippedType, isArray, baseTypeSize, arraySizes };
    }
    if (strippedType.startsWith('int')) {
        baseTypeSize = parseInt(strippedType.substring(3), 10);
        strippedType = 'int';
    }
    else if (strippedType.startsWith('uint')) {
        baseTypeSize = parseInt(type.substring(4), 10);
        strippedType = 'uint';
    }
    else if (strippedType.startsWith('bytes')) {
        baseTypeSize = parseInt(strippedType.substring(5), 10);
        strippedType = 'bytes';
    }
    else {
        return { baseType: undefined, isArray: false, baseTypeSize: undefined, arraySizes };
    }
    return { baseType: strippedType, isArray, baseTypeSize, arraySizes };
};
exports.parseBaseType = parseBaseType;
const abiSchemaToJsonSchema = (abis, level = '/0') => {
    const schema = {
        type: 'array',
        items: [],
        maxItems: abis.length,
        minItems: abis.length,
    };
    for (const [index, abi] of abis.entries()) {
        let abiType;
        let abiName;
        let abiComponents = [];
        if ((0, abi_1.isAbiParameterSchema)(abi)) {
            abiType = abi.type;
            abiName = abi.name;
            abiComponents = abi.components;
        }
        else if (typeof abi === 'string') {
            abiType = abi;
            abiName = `${level}/${index}`;
        }
        else if (Array.isArray(abi)) {
            if (abi[1] && Array.isArray(abi[1])) {
                abiType = abi[0];
                abiName = `${level}/${index}`;
                abiComponents = abi[1];
            }
            else {
                abiType = 'tuple';
                abiName = `${level}/${index}`;
                abiComponents = abi;
            }
        }
        const { baseType, isArray, arraySizes } = (0, exports.parseBaseType)(abiType);
        let childSchema;
        let lastSchema = schema;
        for (let i = arraySizes.length - 1; i > 0; i -= 1) {
            childSchema = {
                type: 'array',
                items: [],
                maxItems: arraySizes[i],
                minItems: arraySizes[i],
            };
            if (arraySizes[i] < 0) {
                delete childSchema.maxItems;
                delete childSchema.minItems;
            }
            lastSchema.items = childSchema;
            lastSchema = childSchema;
        }
        if (baseType === 'tuple' && !isArray) {
            const nestedTuple = (0, exports.abiSchemaToJsonSchema)(abiComponents, abiName);
            nestedTuple.$id = abiName;
            lastSchema.items.push(nestedTuple);
        }
        else if (baseType === 'tuple' && isArray) {
            const arraySize = arraySizes[0];
            const item = {
                $id: abiName,
                type: 'array',
                items: (0, exports.abiSchemaToJsonSchema)(abiComponents, abiName),
                maxItems: arraySize,
                minItems: arraySize,
            };
            if (arraySize < 0) {
                delete item.maxItems;
                delete item.minItems;
            }
            lastSchema.items.push(item);
        }
        else if (isArray) {
            const arraySize = arraySizes[0];
            const item = {
                type: 'array',
                $id: abiName,
                items: {
                    eth: baseType,
                },
                minItems: arraySize,
                maxItems: arraySize,
            };
            if (arraySize < 0) {
                delete item.maxItems;
                delete item.minItems;
            }
            lastSchema.items.push(item);
        }
        else if (Array.isArray(lastSchema.items)) {
            lastSchema.items.push({ $id: abiName, eth: abiType });
        }
        else {
            lastSchema.items.items.push({
                $id: abiName,
                eth: abiType,
            });
        }
    }
    return schema;
};
exports.abiSchemaToJsonSchema = abiSchemaToJsonSchema;
const ethAbiToJsonSchema = (abis) => (0, exports.abiSchemaToJsonSchema)(abis);
exports.ethAbiToJsonSchema = ethAbiToJsonSchema;
const fetchArrayElement = (data, level) => {
    if (level === 1) {
        return data;
    }
    return (0, exports.fetchArrayElement)(data[0], level - 1);
};
exports.fetchArrayElement = fetchArrayElement;
const transformJsonDataToAbiFormat = (abis, data, transformedData) => {
    const newData = [];
    for (const [index, abi] of abis.entries()) {
        let abiType;
        let abiName;
        let abiComponents = [];
        if ((0, abi_1.isAbiParameterSchema)(abi)) {
            abiType = abi.type;
            abiName = abi.name;
            abiComponents = abi.components;
        }
        else if (typeof abi === 'string') {
            abiType = abi;
        }
        else if (Array.isArray(abi)) {
            if (abi[1] && Array.isArray(abi[1])) {
                abiType = abi[0];
                abiComponents = abi[1];
            }
            else {
                abiType = 'tuple';
                abiComponents = abi;
            }
        }
        const { baseType, isArray, arraySizes } = (0, exports.parseBaseType)(abiType);
        const dataItem = Array.isArray(data)
            ? data[index]
            : data[abiName];
        if (baseType === 'tuple' && !isArray) {
            newData.push((0, exports.transformJsonDataToAbiFormat)(abiComponents, dataItem, transformedData));
        }
        else if (baseType === 'tuple' && isArray) {
            const tupleData = [];
            for (const tupleItem of dataItem) {
                if (arraySizes.length > 1) {
                    const nestedItems = (0, exports.fetchArrayElement)(tupleItem, arraySizes.length - 1);
                    const nestedData = [];
                    for (const nestedItem of nestedItems) {
                        nestedData.push((0, exports.transformJsonDataToAbiFormat)(abiComponents, nestedItem, transformedData));
                    }
                    tupleData.push(nestedData);
                }
                else {
                    tupleData.push((0, exports.transformJsonDataToAbiFormat)(abiComponents, tupleItem, transformedData));
                }
            }
            newData.push(tupleData);
        }
        else {
            newData.push(dataItem);
        }
    }
    transformedData = transformedData !== null && transformedData !== void 0 ? transformedData : [];
    transformedData.push(...newData);
    return transformedData;
};
exports.transformJsonDataToAbiFormat = transformJsonDataToAbiFormat;
const codePointToInt = (codePoint) => {
    if (codePoint >= 48 && codePoint <= 57) {
        return codePoint - 48;
    }
    if (codePoint >= 65 && codePoint <= 70) {
        return codePoint - 55;
    }
    if (codePoint >= 97 && codePoint <= 102) {
        return codePoint - 87;
    }
    throw new Error(`Invalid code point: ${codePoint}`);
};
exports.codePointToInt = codePointToInt;
const hexToNumber = (value) => {
    if (!(0, string_1.isHexStrict)(value)) {
        throw new Error('Invalid hex string');
    }
    const [negative, hexValue] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];
    const num = BigInt(hexValue);
    if (num > Number.MAX_SAFE_INTEGER) {
        return negative ? -num : num;
    }
    if (num < Number.MIN_SAFE_INTEGER) {
        return num;
    }
    return negative ? -1 * Number(num) : Number(num);
};
exports.hexToNumber = hexToNumber;
const numberToHex = (value) => {
    if ((typeof value === 'number' || typeof value === 'bigint') && value < 0) {
        return `-0x${value.toString(16).slice(1)}`;
    }
    if ((typeof value === 'number' || typeof value === 'bigint') && value >= 0) {
        return `0x${value.toString(16)}`;
    }
    if (typeof value === 'string' && (0, string_1.isHexStrict)(value)) {
        const [negative, hex] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];
        const hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];
        return `${negative ? '-' : ''}0x${hexValue.replace(/^0+/, '').toLowerCase()}`;
    }
    if (typeof value === 'string' && !(0, string_1.isHexStrict)(value)) {
        return (0, exports.numberToHex)(BigInt(value));
    }
    throw new web3_errors_1.InvalidNumberError(value);
};
exports.numberToHex = numberToHex;
const padLeft = (value, characterAmount, sign = '0') => {
    if (typeof value === 'string' && !(0, string_1.isHexStrict)(value)) {
        return value.padStart(characterAmount, sign);
    }
    const hex = typeof value === 'string' && (0, string_1.isHexStrict)(value) ? value : (0, exports.numberToHex)(value);
    const [prefix, hexValue] = hex.startsWith('-') ? ['-0x', hex.slice(3)] : ['0x', hex.slice(2)];
    return `${prefix}${hexValue.padStart(characterAmount, sign)}`;
};
exports.padLeft = padLeft;
//# sourceMappingURL=utils.js.map